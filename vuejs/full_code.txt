Directory Tree:
vuejs/
â”‚   â”œâ”€â”€ .browserslistrc
â”‚   â”œâ”€â”€ .editorconfig
â”‚   â”œâ”€â”€ .firebaserc
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ firebase.json
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ jsconfig.json
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ vite.config.mjs
â”‚   â”œâ”€â”€ vite.config.mjs.timestamp-1736595480955-9cf38b2de26f6.mjs
â”‚   â”œâ”€â”€ .firebase/ [EXCLUDED]
â”‚   â”œâ”€â”€ .vscode/ [EXCLUDED]
â”‚   â”œâ”€â”€ dist/ [EXCLUDED]
â”‚   â”œâ”€â”€ fotos/ [EXCLUDED]
â”‚   â”œâ”€â”€ node_modules/ [EXCLUDED]
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ robots.txt
â”‚   â”‚   â”œâ”€â”€ img/
â”‚   â”‚   â”‚   â”œâ”€â”€ icons/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ android-chrome-192x192.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ android-chrome-512x512.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ android-chrome-maskable-192x192.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ android-chrome-maskable-512x512.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon-120x120.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon-152x152.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon-180x180.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon-60x60.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon-76x76.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ apple-touch-icon.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ favicon-16x16.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ favicon-32x32.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ msapplication-icon-144x144.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mstile-150x150.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ safari-pinned-tab.svg
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â”œâ”€â”€ classes.js
â”‚   â”‚   â”œâ”€â”€ convert.py
â”‚   â”‚   â”œâ”€â”€ helpers.js
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â”œâ”€â”€ pdf_utils.js
â”‚   â”‚   â”œâ”€â”€ scan_api_classes.js
â”‚   â”‚   â”œâ”€â”€ tempCodeRunnerFile.js
â”‚   â”‚   â”œâ”€â”€ .vscode/ [EXCLUDED]
â”‚   â”‚   â”œâ”€â”€ assets/ [EXCLUDED]
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”‚   â”œâ”€â”€ full_view/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MainLayout.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NavigationDrawer.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RequestDialog.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SectionList.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SubsectionList.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnalyzeSection/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AnalyzeSection.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GroupAnalysis.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ IndividualAnalysis.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GradeSection/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GradeSection.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GradeStudents.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ScanSection/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GenerateStudents.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoadPages.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ScanPages.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ScanSection.vue
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TestSection/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DownloadTest.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GenerateQuestion.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LearningTargets.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PdfDataDisplay.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PdfLoader.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ QuestionEditor.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ QuestionsEditor.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RubricEditor.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TestSection.vue
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TestStructure.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ image/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ImagesPreview.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ sub/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RequestLoader.vue
â”‚   â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”‚   â”œâ”€â”€ vuetify.js
â”‚   â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”‚   â”œâ”€â”€ data_store.js
â”‚   â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”‚   â”œâ”€â”€ AnalisisView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ FullView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ HomeView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ PdfView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ ScanView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ ScanViewOld.vue
â”‚   â”‚   â”œâ”€â”€ workers/
â”‚   â”‚   â”‚   â”œâ”€â”€ pdf.worker.js




# ======================
# File: firebase.json
# ======================

{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}


# ======================
# File: index.html
# ======================

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="./src/assets/HAL.png" sizes="32x32"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PWS toetsen met AI</title>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.js"></script>
</body>

</html>


# ======================
# File: jsconfig.json
# ======================

{
  "compilerOptions": {
    "allowJs": true,
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "bundler",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  }
}


# ======================
# File: README.md
# ======================

# Vuetify (Default)

This is the official scaffolding tool for Vuetify, designed to give you a head start in building your new Vuetify application. It sets up a base template with all the necessary configurations and standard directory structure, enabling you to begin development without the hassle of setting up the project from scratch.

## â—ï¸ Important Links

- ðŸ“„ [Docs](https://vuetifyjs.com/)
- ðŸš¨ [Issues](https://issues.vuetifyjs.com/)
- ðŸ¬ [Store](https://store.vuetifyjs.com/)
- ðŸŽ® [Playground](https://play.vuetifyjs.com/)
- ðŸ’¬ [Discord](https://community.vuetifyjs.com)

## ðŸ’¿ Install

Set up your project using your preferred package manager. Use the corresponding command to install the dependencies:

| Package Manager                                                | Command        |
|---------------------------------------------------------------|----------------|
| [yarn](https://yarnpkg.com/getting-started)                   | `yarn install` |
| [npm](https://docs.npmjs.com/cli/v7/commands/npm-install)     | `npm install`  |
| [pnpm](https://pnpm.io/installation)                          | `pnpm install` |
| [bun](https://bun.sh/#getting-started)                        | `bun install`  |

After completing the installation, your environment is ready for Vuetify development.

## âœ¨ Features

- ðŸ–¼ï¸ **Optimized Front-End Stack**: Leverage the latest Vue 3 and Vuetify 3 for a modern, reactive UI development experience. [Vue 3](https://v3.vuejs.org/) | [Vuetify 3](https://vuetifyjs.com/en/)
- ðŸ—ƒï¸ **State Management**: Integrated with [Pinia](https://pinia.vuejs.org/), the intuitive, modular state management solution for Vue.
- ðŸš¦ **Routing and Layouts**: Utilizes Vue Router for SPA navigation and vite-plugin-vue-layouts for organizing Vue file layouts. [Vue Router](https://router.vuejs.org/) | [vite-plugin-vue-layouts](https://github.com/JohnCampionJr/vite-plugin-vue-layouts)
- âš¡ **Next-Gen Tooling**: Powered by Vite, experience fast cold starts and instant HMR (Hot Module Replacement). [Vite](https://vitejs.dev/)
- ðŸ§© **Automated Component Importing**: Streamline your workflow with unplugin-vue-components, automatically importing components as you use them. [unplugin-vue-components](https://github.com/antfu/unplugin-vue-components)

These features are curated to provide a seamless development experience from setup to deployment, ensuring that your Vuetify application is both powerful and maintainable.

## ðŸ’¡ Usage

This section covers how to start the development server and build your project for production.

### Starting the Development Server

To start the development server with hot-reload, run the following command. The server will be accessible at [http://localhost:3000](http://localhost:3000):

```bash
yarn dev
```

(Repeat for npm, pnpm, and bun with respective commands.)

> Add NODE_OPTIONS='--no-warnings' to suppress the JSON import warnings that happen as part of the Vuetify import mapping. If you are on Node [v21.3.0](https://nodejs.org/en/blog/release/v21.3.0) or higher, you can change this to NODE_OPTIONS='--disable-warning=5401'. If you don't mind the warning, you can remove this from your package.json dev script.

### Building for Production

To build your project for production, use:

```bash
yarn build
```

(Repeat for npm, pnpm, and bun with respective commands.)

Once the build process is completed, your application will be ready for deployment in a production environment.

## ðŸ’ª Support Vuetify Development

This project is built with [Vuetify](https://vuetifyjs.com/en/), a UI Library with a comprehensive collection of Vue components. Vuetify is an MIT licensed Open Source project that has been made possible due to the generous contributions by our [sponsors and backers](https://vuetifyjs.com/introduction/sponsors-and-backers/). If you are interested in supporting this project, please consider:

- [Requesting Enterprise Support](https://support.vuetifyjs.com/)
- [Sponsoring John on Github](https://github.com/users/johnleider/sponsorship)
- [Sponsoring Kael on Github](https://github.com/users/kaelwd/sponsorship)
- [Supporting the team on Open Collective](https://opencollective.com/vuetify)
- [Becoming a sponsor on Patreon](https://www.patreon.com/vuetify)
- [Becoming a subscriber on Tidelift](https://tidelift.com/subscription/npm/vuetify)
- [Making a one-time donation with Paypal](https://paypal.me/vuetify)

## ðŸ“‘ License
[MIT](http://opensource.org/licenses/MIT)

Copyright (c) 2016-present Vuetify, LLC


# ======================
# File: src\App.vue
# ======================

<template lang="pug">
v-app
    v-main
        router-view
</template>

<script>
// Data 


// Components


export default {
    name: 'App',
    components: {
    
    },
    props: {
    
    },
    emits: [],
    setup() {
        
    },
    data(){
        return {
             
        }
    },
    computed: {
    
    },
    methods: {
    
    },
    watch: {
    
    },
    // created() {
    
    // },
    mounted() {
    },
    
    
}
</script>
    
<style >
html {
    overflow-y: hidden;
}

h1, h2, h3, h4, p{
    white-space: pre-wrap;
    word-wrap: break-word;
    -webkit-hyphens: auto;
    -moz-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
}

::-webkit-scrollbar {
    width: 6px;
    height: 6px;
    border-radius: 6px;
    background: #5a5a5a47;

}
 
/* Track */
/* ::-webkit-scrollbar-track {
} */

/* Handle */
::-webkit-scrollbar-thumb {
    opacity: 0.6;
    /* border: solid 1px #13163b; */
    background: #646464;
    border-radius: 6px;
}

.v-btn__content { width: 100%; white-space: normal; }

.truncate { 
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>


# ======================
# File: src\classes.js
# ======================

// Importing required libraries (not needed in the same way as Python)
import { v4 as uuidv4 } from 'uuid' 
import { sum, erf, average, standardDeviation } from '@/helpers'
import jsStat from 'jstat'

const data_classes = {}


// Correlation function
function correlation(list1, list2) {
    const n = list1.length;
    if (list1.length !== list2.length || n <= 1) return null;

    const list1Mean = list1.reduce((sum, val) => sum + val, 0) / n;
    const list2Mean = list2.reduce((sum, val) => sum + val, 0) / n;

    const cov = list1.reduce((sum, val, i) => sum + (val - list1Mean) * (list2[i] - list2Mean), 0) / (n - 1);
    
    const list1Stdev = standardDeviation(list1);
    const list2Stdev = standardDeviation(list2);
    
    return cov / (list1Stdev * list2Stdev);
}
data_classes.correlation = correlation

class NormalDistribution {
    constructor({
        mean=10,
        standard_deviation=3,
        values=null
    }){
        if (values){
            mean = average(values)
            standard_deviation = standardDeviation(values)
        }

        this.mean = mean
        this.standard_deviation =standard_deviation
    }
    steekproef(n){
        return NormalDistribution({mean: this.mean, standard_deviation: this.standard_deviation/ Math.sqrt(n)})
    }
    is_risk(alfa, steekproef_n, steekproef_resultaat){
        const steekproeven = this.steekproef(steekproef_n)
    
        const voorschrift = steekproeven.invNorm(alfa/2)
    
        const h0 = steekproeven.mean
        const h1 = steekproef_resultaat < voorschrift[0] && steekproef_resultaat > voorschrift[1]
    
        returnÂ !h1
    }
    pdf(x){
        return (1 / (this.standard_deviation * Math.sqrt(2*Math.PI)) * Math.pow(Math.E, -0.5*Math.pow((x-this.mean) / this.standard_deviation, 2)))
    }
    erf(x){

    }
    cdf(x){
        return 0.5*(1+erf((x-this.mean) / (this.standard_deviation*Math.SQRT2)))
    }
    invNorm(opp, dir='LEFT'){
        if (dir=='LEFT'){
            const inv = jsStat.normal.inv(opp, this.mean, this.standard_deviation)

            return inv
        } 
        if (dir=='RIGHT'){
            const inv = jsStat.normal.inv(opp, this.mean, this.standard_deviation)

            return this.mean + (this.mean - inv)
        }
        if (dir == 'CENTER'){
            const inv = jsStat.normal.inv((1-opp)/2, this.mean, this.standard_deviation)

            // const diff = this.mean - inv
            return [inv, this.mean - (inv - this.mean)]
        }
        return NaN
    }
}
data_classes.NormalDistribution = NormalDistribution

class BaseClass {
    constructor(){}
    // set without changing reference
    set(val){
        Object.keys(this).forEach(key => {
            if (Object.keys(val).includes(key)){
                this[key] = val[key]
            }
        })
    }
}



// GradeFormula class
class GradeFormula extends BaseClass {
    constructor(id = uuidv4(), name = "Method name", method = (percent) => (9 * percent + 1)) {
        super()
        this.id = id;
        this.name = name;
        this.method = method;
    }
}
data_classes.GradeFormula = GradeFormula

// Question class
class Question extends BaseClass {
    constructor({total_points, question_number, id = uuidv4(), sections = []}) {
        super()
        this.id = id;
        this.question_number = question_number;
        this.original_points = total_points;
        this.sections = sections;
        this.total_points = total_points; // changed by user
    }
}
data_classes.Question = Question

class Student extends BaseClass {
    constructor({id = uuidv4(), name=""}){
        super()
        this.id = id
        this.name = name
    }
}
data_classes.Student = Student

// Result class
class Result extends BaseClass {
    constructor({question = new Question(), student = {}, points = 1, id = uuidv4()}) {
        super()
        this.id = id;
        this.question = question;
        this.student = student;
        this._points = points; // private variable
    }

    get total_points() {
        return this.question.total_points;
    }

    get question_number() {
        return this.question.question_number;
    }

    get points() {
        return this._points;
    }

    set points(value) {
        this._points = value; // Ensure points are set
    }

    get percent() {
        return this.points / this.total_points;
    }
}
data_classes.Result = Result

// ResultBundle class
class ResultBundle extends BaseClass {
    constructor({
        results = [], 
        id = uuidv4(), 
        test = {}
    }) {
        super()
        this.id = id;
        this.test = test;
        this.results = results;
    }

    [Symbol.iterator]() {
        return this.results[Symbol.iterator]();
    }

    get grade() {
        return this.test.grade_formula.method(this.points / this.total_points);
    }

    get points() {
        return this.results.reduce((sum, result) => sum + result.points, 0);
    }

    get total_points() {
        return this.results.reduce((sum, result) => sum + result.total_points, 0);
    }
    get average_points(){
        return this.points / this.results.length
    }

    get average_percent(){
        return this.results.reduce((sum, result) => sum + result.percent, 0) / this.results.length;
    }
    get average(){
        if (this.test.data_type == 'points'){
            return this.average_points
        } 
        if (this.test.data_type == 'percent'){
            return this.average_percent * 100
        } 
    }


    get standard_deviation_points(){
        return standardDeviation(this.results.map(result => result.points));
    }

    get standard_deviation_percent(){
        return standardDeviation(this.results.map(result => result.percent));
    }
    get standard_deviation(){
        if (this.test.data_type == 'points'){
            return this.standard_deviation_points
        } 
        if (this.test.data_type == 'percent'){
            return this.standard_deviation_percent * 100
        } 
    }





    addResult(result){
        this.results.push(result)
    }

    getStudentResults(student_id) {
        return new ResultBundle({
            results: this.results.filter(result => result.student.id === student_id),
            test: this.test
        });
    }

    getQuestionResults(question_id) {
        return new ResultBundle({
            results: this.results.filter(result => result.question.id === question_id),
            test: this.test
        });
    }

    getSectionResults(sectionId) {
        return new ResultBundle({
            results: this.results.filter(result => result.question.sections.some(section => section.id === sectionId)),
            test: this.test
        });
    }

    addResult(questionResult) {
        this.results.push(questionResult);
    }

    standardDeviation() {
        return standardDeviation(this.results.map(result => result.percent));
    }

    getTypeCorrelation(id_type, id1, id2) {
        let results1, results2, func;
        if (id_type === "student") {
            results1 = this.getStudentResults(id1).results;
            results2 = this.getStudentResults(id2).results;
            func = (target, current) => current.question.id === target.question.id;
        } else if (id_type === "question") {
            results1 = this.getQuestionResults(id1).results;
            results2 = this.getQuestionResults(id2).results;
            func = (target, current) => current.student.id === target.student.id;
        } else if (id_type === "section") {
            results1 = this.getSectionResults(id1).results;
            results2 = this.getSectionResults(id2).results;
            func = (target, current) => current.question.id === target.question.id;
        } else {
            return null;
        }
        const relatedList = [];

        for (const result of results1) {
            const answers = results2.filter(current => func(result, current));
            if (answers.length === 0) continue;
            relatedList.push([result, answers[0]]);
        }

        const list1 = relatedList.map(relation => relation[0]);
        const list2 = relatedList.map(relation => relation[1]);

        const value1 = list1.map(x => x.percent);
        const value2 = list2.map(x => x.percent);

        return correlation(value1, value2);
    }

    getTypeCorrelations(id_type, id1, id2) {
        // Implementation here...
    }
}
data_classes.ResultBundle = ResultBundle


// Section class
class Section extends BaseClass {
    constructor({id = uuidv4(), name = "", description = ""}) {
        super()
        this.id = id;
        this.name = name;
        this.description = description;
    }
}
data_classes.Section = Section

// Test class
class Test extends BaseClass {
    constructor({
        id = uuidv4(), 
        name = "", 
        results = new ResultBundle({}), 
        grade_formula = new GradeFormula({}), 
        questions=[],
        students=[],
        sections=[],

        data_type='points'
    }) {
        super()
        this.id = id;
        this.name = name;
        results.test = this
        this.results = results;
        
        this.original_grade_formula = grade_formula;
        this.grade_formula = grade_formula; // changed by user
        this.questions = questions
        this.students = students
        this.sections = sections

        this.data_type = data_type
    }
    getJsonRows(data_type="point"){
        
        const getData = (result) => {
            switch (data_type) {
                case "points":
                    return result.points
                    break;
                case "percent":
                    return result.percent

                    break;          
                default:
                    return 0
                    break;
            }
        }
        const getTotal = (result) => {
            switch (data_type) {
                case "points":
                    return result.total_points
                    break;
                case "percent":
                    return 1

                    break;          
                default:
                    break;
            }
        }
        
        const rows = [{
                id: 'Max', 
                ...this.questions.reduce((data,e) => {data['Q'+e.question_number] = getTotal(e); return data}, {}), 
                total: sum(this.questions.map(e => getTotal(e))),
                average: 1
            }, 
            ...this.students.map(student => {
                const result_bundle = this.results.getStudentResults(student.id)
                const results = result_bundle.results
                // console.log(results)
                const data = {
                    id: student.id,
                    ...results.reduce((row, result) => { 
                        row['Q'+result.question.question_number] = getData(result)

                        return row
                    }, {}),
                    total: result_bundle.points,
                    average: {
                        points: result_bundle.average_points,
                        percent: result_bundle.average_percent
                    }[data_type]
                }
                return data

            })
        ]
        return rows

    }
}
data_classes.Test = Test

// Example usage
export default data_classes

# ======================
# File: src\convert.py
# ======================

import json

with open('src/saved_section_data.json', 'r') as f:
    data = json.load(f)
    
def getSection(section):
    return {
        "id" : section["id"],
        "answer" : section["answer"],
        "student_id" : section["student_id"],
        "question_number" : section["question_number"],
    }
    
new_data = []
for student in data:
    new_data.append({
        "student_id": student["student_id"],
        "sections": [getSection(x) for x in student["sections"]]
    })
    
with open('saved_section_data2.json', 'w') as f:
    json.dump(new_data, f, indent=4)

# ======================
# File: src\helpers.js
# ======================

import {
  read,
  utils
} from 'xlsx'
import _ from 'lodash'
import CircularJSON from 'circular-json'
import {
  v4 as uuidv4
} from 'uuid'
import axios from 'axios'
import {
    ref
} from 'vue'
import prettyMilliseconds from 'pretty-ms';


// import sharp from 'sharp';

/**
 * Loads the data and does a quick analysis
 *
 * Jonathan -- 28-09-'24
 */

function excelFileToJSON(file) {
  var reader = new FileReader();
  reader.readAsBinaryString(file);
  return new Promise((resolve, reject) => {
    reader.onload = function (e) {
      var data = e.target.result;
      var workbook = read(data, {
        type: "binary",
      });
      var result = {};
      workbook.SheetNames.forEach(function (sheetName) {
        var roa = utils.sheet_to_row_object_array(
          workbook.Sheets[sheetName]
        );
        if (roa.length > 0) {
          result[sheetName] = roa;
        }
      });
      resolve(result);
    };
  });
}

function sum(l) {
  return l.reduce((data, current) => data + current, 0)
}

function uncircularStringify(obj) {
  return CircularJSON.stringify(obj)
}

function erf(x, n) {
  const h = x / n;
  let sum = 0;

  for (let i = 1; i < n; i++) {
    const xi = i * h;
    sum += (i % 2 === 0 ? 4 : 2) * Math.exp(-xi * xi);
  }

  return 2 * h / 3 * (Math.exp(-x * x) + sum + 2 * Math.exp(0));
}

function average(data) {
  return sum(data) / data.length
}

// Standard Deviation function
function standardDeviation(data) {
  const average = sum(data) / data.length;
  return Math.sqrt(data.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / (data.length - 1));
}

function decCount(num) {
  if (Math.floor(num.valueOf()) === num.valueOf()) return 0;
  return num.toString().split(".")[1].length || 0;
}

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function getRandomID() {
  return uuidv4()
}

function downloadJSON(object, filename) {
  const dataStr = JSON.stringify(object);
  const dataUri = 'data:text/json;charset=utf-8,' + encodeURIComponent(dataStr);

  const link = document.createElement('a');
  link.setAttribute('href', dataUri);
  link.setAttribute('download', filename + '.json');
  link.click();
}

function imageToPngBase64(imageSource) {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    img.onload = () => {
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      ctx.drawImage(img, 0, 0);
      const base64String = canvas.toDataURL('image/png');
      resolve(base64String);
    };

    img.onerror = (error) => {
      reject(new Error(`Failed to load image: ${error.message || 'Unknown error'}`));
    };

    if (typeof imageSource === 'string') {
      // Assume it's a URL
      img.crossOrigin = 'Anonymous'; // For handling CORS if needed
      img.src = imageSource;
    } else if (imageSource instanceof File) {
      // Handle File object (from <input type="file">)
      const reader = new FileReader();
      reader.onload = (e) => {
        img.src = e.target.result;
      };
      reader.onerror = () => {
        reject(new Error('Failed to read the file.'));
      };
      reader.readAsDataURL(imageSource);
    } else if (imageSource instanceof HTMLImageElement) {
      // Handle already loaded Image element
      img.src = imageSource.src;
    } else {
      reject(new Error('Unsupported image source type. Please provide a URL, File object, or HTMLImageElement.'));
    }
  });
}
async function rotateImage180(base64Image) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = image.width;
      canvas.height = image.height;

      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(Math.PI); // 180 degrees in radians
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      ctx.drawImage(image, 0, 0);

      resolve(canvas.toDataURL('image/png'));
    };
    image.onerror = reject; // Handle potential errors
    image.src = base64Image;
  });
}
const delay = (ms) => new Promise(res => setTimeout(res, ms));

var total_requests = ref(0)
const use_localhost = true


var endpoint = (use_localhost&&(location.hostname === "localhost" || location.hostname === "127.0.0.1")) ? 'http://localhost:8080' : 'https://toetspws-function-771520566941.europe-west4.run.app'
axios.defaults.timeout = 360_000;

var active_requests = ref([])

const apiRequest = async (route, data) => {

    total_requests.value += 1
    try{
        const source = axios.CancelToken.source();
        var id = getRandomID()

        const removeRequest = () => {
                const index = active_requests.value.findIndex(e => e.id == id)    
                if (index != -1){
                    active_requests.value.splice(index, 1)
                }
        }

        var request = axios.post(
            endpoint+route, 
            data, 
            {
                cancelToken: source.token,
            }
        ).then( e => {
            removeRequest()
            return e
        }).catch(e => {
            removeRequest()
            return e
        });
        const request_datetime = new Date().getTime()
        active_requests.value.push({
            id: id,
            route: route,
            params: data,
            request: request,
            request_timestamp: request_datetime,
            source: source,
            prettyDuration: () => {return prettyMilliseconds(new Date().getTime() - request_datetime)} ,
            abort: () => {
                source.cancel("Request aborted")
                removeRequest()
            }

        })
        
        var response = await request

    } catch (e) {
        var response = {
            type: 'server error',
            error: e
        }
    }
    

    if (response.data
    && response.data.output){
        return response.data.output
    }

    console.warn('Request error', response)

    return response
}

function downloadFileFromBase64(base64String, filename = 'downloaded', datatype="pdf") {
    /**
    * Downloads a PDF file from a base64 encoded string.
    *
    * Args:
    *   base64String: The base64 encoded string of the PDF.
    *   filename: The desired filename for the downloaded PDF (optional, default: 'downloaded.pdf').
    */

    filename += '.' + datatype
    if (datatype == 'pdf'){
        var dataPrefix = 'data:application/pdf;base64,';
    } else if (datatype == 'docx'){
        var dataPrefix = 'data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,'
    }
    const linkSource = base64String.startsWith(dataPrefix) ? base64String : `${dataPrefix}${base64String}`;
    const downloadLink = document.createElement("a");
    downloadLink.href = linkSource;
    downloadLink.download = filename;
    downloadLink.click();
    downloadLink.remove();
}
function blobToBase64(blob) {
  return new Promise((resolve, _) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.readAsDataURL(blob);
  });
}

async function downloadTest(test_data, feedback_field=false, filename="Toets"){
    const result = await apiRequest('/test-pdf', {
        testData: test_data,
    })
    if (typeof result == 'string'){

        downloadFileFromBase64(result, filename, test_data["settings"]["output_type"])
    } else {
        console.log('error: ', result)
    }
    
}

async function downloadResultPdf(results, feedback_field=false, filename="StudentResult"){
    const result = await apiRequest('/student-result-pdf', {
        studentResults: results,
        addStudentFeedback: feedback_field
    })
    if (typeof result == 'string'){

        downloadFileFromBase64(result, filename)
    } else {
        console.log('error: ', result)
    }
    
}


export {
  excelFileToJSON,
  sum,
  uncircularStringify,
  erf,
  average,
  standardDeviation,
  decCount,
  isNumeric,
  getRandomID,
  downloadJSON,
  imageToPngBase64,
  rotateImage180,
  delay,
  apiRequest,
  downloadResultPdf,
  downloadFileFromBase64,
  downloadTest,
  total_requests,
  blobToBase64,
  active_requests
}


# ======================
# File: src\main.js
# ======================

/**
 * main.js
 *
 * Bootstraps Vuetify and other plugins then mounts the App`
 */

// Plugins
import { registerPlugins } from '@/plugins'
import vuePugPlugin from 'vue-pug-plugin'
import { createPinia } from 'pinia'
const pinia = createPinia()
import VueApexCharts from "vue3-apexcharts";
import { vFullscreenImgInstall } from 'maz-ui'
import router from './router'
import pdfUtilsPlugin from './pdf_utils';
import PDFObjectPlugin from 'pdfobject-vue';
import { VueDraggableNext } from 'vue-draggable-next'

// Components
import App from './App.vue'

// Composables
import { createApp } from 'vue'

const app = createApp(App)
registerPlugins(app)

app
    .use(VueApexCharts)
    .use(pinia)
    .use(router)
    .use(vFullscreenImgInstall)
    .use(vuePugPlugin)
    .use(pdfUtilsPlugin)
    .use(PDFObjectPlugin)
    .component("draggable", VueDraggableNext)


const globals = app.config.globalProperties

app.mount('#app')

export {
    globals
}


# ======================
# File: src\pdf_utils.js
# ======================

import * as pdfjsLib from 'pdfjs-dist/build/pdf';
// Import the worker directly
import PdfWorker from '@/workers/pdf.worker.js?worker&inline';
import * as pdfjsWorker from  'pdfjs-dist/build/pdf.worker';


import {
    pdfToBase64Images as workerPdfToBase64Images,
    extractTextAndImages as workerExtractTextAndImages
} from '@/workers/pdf.worker.js'; // Import worker functions

const pdfUtilsPlugin = {
  install: (app) => {
    // Configure worker source
    pdfjsLib.GlobalWorkerOptions.workerSrc =  `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.js`;

    app.config.globalProperties.$pdfToBase64Images = async (file) => {
      return new Promise(async (resolve) => {
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(file);
        fileReader.onload = async () => {
          const pdfData = fileReader.result;
          const base64Images = await workerPdfToBase64Images(pdfData);
          resolve(base64Images);
        };
      });
    };

    app.config.globalProperties.$extractTextAndImages = async (file) => {
      return new Promise(async (resolve) => {
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(file);
        fileReader.onload = async () => {
          const pdfData = fileReader.result;
          const extractedData = await workerExtractTextAndImages(pdfData);
          resolve(extractedData);
        };
      });
    };
  },
};

// Configure worker source (only needs to be done once)
// pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('pdfjs-dist/legacy/build/pdf.worker.js', import.meta.url).href;

export default pdfUtilsPlugin;


# ======================
# File: src\scan_api_classes.js
# ======================

import {
    getRandomID,
    delay,
    sum,
    apiRequest,
    downloadResultPdf,
    downloadTest
} from '@/helpers';
import {
    globals
} from '@/main'





var temp_saved_grade_data = {}
var temp_section_data = []



class ContextData {
    constructor({
        contexts = {},
        questions = {},
        rubrics = {},
    }) {
        this.contexts = contexts
        this.questions = questions
        this.rubrics = rubrics
    }
    getQuestion(id) {
        return this.questions[id] || ""
    }
    getRubric(id) {
        return this.rubrics[id] || ""
    }
    getContext(id) {
        return this.contexts[id] || ""
    }
}


class ScanPage {
    constructor(base64Image, context_data = new ContextData({})) {
        this.base64Image = base64Image;
        this.id = getRandomID()

        this.student_id = null;
        this.colorCorrected = null;
        this.redPenExtracted = null;
        this.croppedImage = null;
        this.squareImage = null;
        this.squareData = [];
        this.sections = [];
        this.questions = [];
        this.total_result = {}
        this.context_data = context_data

        this.is_loading_all = false;
        this.loading = {
                all: false,

                student_id: false,
                crop: false,
                col_cor: false,

                detect_squares: false,
                detect_qr: false,

                create_sections: false,
                create_question: false,

            },
            this.selected_image_type = 'raw'


    }
    get is_loading() {
        return Object.values(this.loading).some(e => e)
    }
    get image() {
        switch (this.selected_image_type) {
            case "raw":
                return this.base64Image
                break;
            case "cropped":
                return this.croppedImage
                break;
            case "colcor":
                return this.colorCorrected
                break;
            default:
                break;
        }

    }
    set image(val) {
        switch (this.selected_image_type) {
            case "raw":
                this.base64Image = val
                break;
            case "cropped":
                this.croppedImage = val
                break;
            case "colcor":
                this.colorCorrected = val
                break;
            default:
                break;
        }

    }
    get image_options() {
        const options = ['raw']
        if (this.croppedImage) {
            options.push('cropped')
        }
        if (this.colorCorrected) {
            options.push('colcor')
        }
        return options
    }
    generateRandomId() {
        return Math.random().toString(36).substring(2, 15);
    }

    async cropImage() {
        try {
            this.loading.crop = true
            const response = await apiRequest('/crop', {
                Base64Image: this.base64Image
            });
            if (response) {
                this.selected_image_type = 'cropped'
                this.croppedImage = response;
            } else {
                console.error('Error cropping image:', response.data);
            }

            this.loading.crop = false
        } catch (error) {
            console.error('API call to crop image failed:', error);
        }
    }
    // Color correction and extraction of red pen marks
    async colorCorrect() {
        this.loading.col_cor = true
        const response = await apiRequest('/extract_red_pen', {
            Base64Image: this.image,
        });
        console.log('colorCorrect: ', response)
        this.colorCorrected = response.clean;
        this.loading.col_cor = false
        this.selected_image_type = 'colcor'
        return this.colorCorrected;
    }

    async detectQrSections() {
        this.loading.detect_qr = true
        const response = await apiRequest('/get_qr_sections', {
            Base64Image: this.image,
        });
        this.squareImage = response?.image || null
        response?.sections?.forEach(e => {
            const section = new ScanSection({
                full: e.section_image,
                question_selector: e.question_selector_image,
                answer: e.section_image,
                question_number: e.data,
                is_qr_section: true
            })

            this.sections.push(section)
        });
        console.log('detectQrSections: ', response)

        this.loading.detect_qr = false
        return this.colorCorrected;
    }
    async detectStudentId() {
        this.loading.student_id = true
        const response = await apiRequest('/get_student_id', {
            Base64Image: this.image,
        });
        console.log('detectStudentId: ', response)

        this.student_id = response?.result?.text || null

        this.loading.student_id = false
    }
    // Detect squares on the image
    async detectSquares() {
        this.loading.detect_squares = true
        const response = await apiRequest('/detect_squares', {
            Base64Image: this.image,
        });
        this.squareData = response?.data || [];
        this.squareImage = response?.image || ""
        this.loading.detect_squares = false
        return this.squareData;
    }
    // calculate everything
    async scanPage() {
        this.loading.all = true
        console.log('started scan page: ', this)
        const response = await apiRequest('/scan_page', {
            Base64Image: this.image,
        });
        console.log('scanPage: ', response)
        this.total_result = response;

        if (this.total_result) {
            this.loadPageDataFromTotal(this.total_result)

        }
        this.loading.all = false
        return this.total_result;
    }

    loadPageDataFromTotal(total) {
        if (!total) {
            return null
        }

        this.student_id = total.student_id_data?.result.text || ""
        this.redPenExtracted = total.red_pen_base64 || ""
        this.croppedImage = total.cropped_base64 || ""
        total.questions.forEach(q => {
            const question = new ScanQuestion({
                base64Image: q.image
            })
            question.base64Image = q.image
            question.question_number = q.question_id.toString()
            question.text = q.text_result?.result?.correctly_spelled_text || ""
            question.student_handwriting_percent = q.text_result?.result?.student_handwriting_percent || ""
            this.questions.push(question)
        })

    }

    // Create sections based on square data
    async createSections() {
        this.loading.create_sections = true
        const response = await apiRequest('/extract_sections', {
            Base64Image: this.image,
            square_data: this.squareData
        });
        if (response?.sections) {

            this.sections = response.sections.map(section => new ScanSection({
                full: section.full,
                section_finder: section.section_finder,
                question_selector: section.question_selector,
                answer: section.answer,
                student_id: this.student_id
            }));
        }
        this.loading.create_sections = false
    }

    // Extract text from sections, turning them into Question objects if they match the criteria
    async extractQuestions() {
        this.loading.create_question = true
        const base64_sections = this.sections.map(section => section.question_selector || "")

        const response = await apiRequest('/question_selector_info', {
            "base64Images": JSON.stringify(base64_sections),
            "checkbox_count": "7"
        })

        if (response.length != base64_sections.length) {
            console.log('Page: ExtractQuestionLengthError: response: ', response.length, '- sections:', this.sections.length, response)
            this.loading.create_question = false
            return
        } else {
            console.log('Page: Extract question number result: ', response)

        }

        response.forEach((response_item, index) => {
            if (!!response_item.selected_checkbox && response_item.selected_checkbox > 0) {
                this.sections[index].question_number = response_item.selected_checkbox
                return
            }
            this.sections[index].question_number = 0
        })


        this.loading.create_question = false
    }
    async loadSections(extract_question = true) {
        await this.detectSquares()
        await this.createSections()
        if (extract_question) {

            await this.extractQuestions()
        }

    }

    // Link with other answer sections
    async linkAnswers() {
        this.is_loading = true
        const unique_questions = [...new Set(this.sections.map(e => e.question_number))].filter(e => e != 0)
        console.log('unique_questions: ', unique_questions)
        const response = await Promise.all(unique_questions.map(async question_number => {
            const response = await apiRequest('/link_answer_sections', {
                sections: this.sections.filter(e => e.question_number == question_number).map(section => section.answer),
            })
            console.log('link answer: ', response)
            return {
                response,
                question_number
            }
        }))
        this.questions = response.map(e => new ScanQuestion({
            base64Image: e.response,
            question_number: e.question_number,
            page: this
        }))

        this.is_loading = false
    }
    async extractText() {
        this.is_loading = true
        await Promise.all(this.questions.map(question => question.extractText()))
        this.is_loading = false
    }

}


class ScanSection {
    constructor({
        full = null,
        section_finder = null,
        question_selector = null,
        answer = null,
        question_number = null,
        question_number_data = null,
        is_qr_section = false,
        student_id = null
    }) {
        this.id = getRandomID()
        this.is_loading = false
        this.full = full
        this.section_finder = section_finder
        this.question_selector = question_selector
        this.answer = answer
        this.is_qr_section = is_qr_section
        this.student_id = student_id
        this.question_number = question_number
        this.question_number_data = question_number_data
    }

    async extractQuestion() {
        this.is_loading = true
        const response = await apiRequest('/question_selector_info', {
            Base64Image: this.question_selector,
        });
        console.log('extractQuestion: ', response)
        this.question_number = response.most_certain_checked_number || 0;
        this.question_number_data = response
        this.is_loading = false
        return response
    }


}
class ScanQuestion {
    constructor({
        base64Image = "",
        question_number = "",
        text = "",
        data = {},
        page = new ScanPage({}),
        is_loading=false
    }) {
        this.id = getRandomID()

        this.base64Image = base64Image
        this.question_number = question_number
        this.text = text
        this.data = data
        this.page = page
        this.is_loading = is_loading
    }


    // Extract text from the section based on the bounding box
    async extractText(context = null, provider=null, model=null) {
        this.is_loading = true

        if (!context) {
            context = this.page.context_data
        }

        const response = await apiRequest('/extract_text', {
            Base64Image: this.base64Image,
            questionText: context.getQuestion(this.question_number.toString()),
            rubricText: context.getQuestion(this.question_number.toString()),
            contextText: context.getContext(this.question_number.toString()),
            provider: provider,
            model: model,
        });
        console.log('extractText: ', response)
        this.text = response.result?.correctly_spelled_text || "";
        this.data = response
        this.is_loading = false
        return {
            text: this.text
        };
    }
    async extractQuestion() {
        const base64_sections = [this.question_selector]

        const response = await apiRequest('/question_selector_info', {
            "base64Images": JSON.stringify(base64_sections),
            "checkbox_count": "7"
        })

        if (response.length != base64_sections.length) {
            console.log('Section: ExtractQuestionLengthError: response: ', response.length, '- sections:', this.sections.length, response)
            this.loading.create_question = false
            return
        } else {
            console.log('Section: Extract question number result: ', response)

        }

        if (response.length > 0) {
            if (!!response[0].selected_checkbox && response[0].selected_checkbox > 0) {

                this.question_number = response[0].selected_checkbox
            } else {
                this.question_number = 0
            }
        }


    }

}


class GptQuestionSettings {
    constructor({
        test = null,
        id = getRandomID(),
        rtti = "i",
        subject = "motor",
        targets = {},
        point_count = 3

    }) {
        this.test = test
        this.id = id
        this.rtti = rtti
        this.subject = subject
        this.targets = targets
        this.point_count = point_count
    }
    get selected_targets() {
        var selected_targets = this.test.targets.filter(target => this.targets[target.id])
        if (selected_targets.length == 0) {
            selected_targets = this.test.targets
        }
        return selected_targets

    }
    get request_text() {
        return `
                Je moet een toets vraag gaan genereren op het juiste niveau.

                Dit is de informatie van de toets:
                School Type: ${this.test.gpt_test.school_type}
                School Jaar: ${this.test.gpt_test.school_year}
                Vak: ${this.test.gpt_test.school_subject}
                ${this.test.gpt_test.subject?.length > 0 ? 'Onderwerp(en):  '+this.test.gpt_test.subject : 'Bedenk zelf de onderwerpen'}
                ${this.test.gpt_test.learned?.length > 0 ? 'Geleerde stof:  '+this.test.gpt_test.learned : ''}
                ${this.test.gpt_test.requested_topics?.length > 0 ? 'Door de docent aangevraagde informatie over de toets: '+this.test.gpt_test.requested_topics : ''}
                

                de vraag moet het volgdende rtti (de R staat voor Reproductie, de eerste T voor Training, de tweede T voor Transfer en de I voor Inzicht) hebben: 
                ${this.rtti}

                ${this.subject.length == 0 ? '' : `De vraag moet over het volgende onderwerp gaan: ${this.subject}`}

                Geef de vraag in het aangegeven schema
                        vraag tekst: de exacte tekst van de vraag
                        question_number: dit is het nummer van de vraag, oftewel vraagnummer.
                        question_context: is de tekst die voor een vraag staat om de situatie te schetsen of de vraag in te leiden, dit is niet altijd nodig
                        is_draw_question: geeft aan of het antwoord bij deze vraag het antwoord geen puur tekstantwoord is
                        points: Haal uit de rubric bij elke vraag de rubric punten, als er geen punten in de rubric staan moet je zelf punten bedenken.
                elk punt heeft:
                        een naam (point_name) met in 1 of 2 woorden waar die punt overgaat
                        een tekst (point_text) met daarin de exacte uitleg van dit punt
                        een nummber (point_index) welk punt dit is, bij deze vraag, start bij 0
                        een gewicht (point_weight) voor hoeveel punten deze rubricpoint mee telt
                        leerdoel (target_name) het leerdoel waar dit punt bij hoort, hieronder kan je zien welke namen je hier mag invullen
                
                hier zijn de leerdoelen die in de vraag/punten moeten voorkomen JE MAG GEEN ANDERE LEERDOEL NAMEN GEBRUIKEN, geef alleen de naam van het leerdoel (voor de ":"):
                ${this.selected_targets.map(e => `${e.target_name}: ${e.explanation}`).join('\n')}
                
                Dit zijn de vragen die al in de toets gestelt zijn, houdt hier rekening mee, zodat je niet 2x hetzelde vraagt:
                ${this.test.questions.map(e => `Vraag ${e.question_number}: ${e.question_text}`).join('\n')}

                Voor de vraag teksten mag je markdown gebruiken 
                Ook kan je dollar tekens gebruiken om latex equations te laten zien
                niewe regels ook toegestaan bij bijvoorbeeld meerkeuzevragen of een opsomming van dingen die een leerling moet beantwoorden.
                ook zijn nieuwe regels in de context toegestaan.

                De vraag mag maximaal ${this.point_count} punten hebben.

                geeft de resultaten in de taal van de gegeven toets(vaak zal dat Nederlands zijn)
                
                Houd je altijd aan het gegeven schema
                `
    }
}

class GptTestSettings {
    constructor({
        test = null,
        id = getRandomID(),
        school_type = "vwo",
        school_year = 3,
        school_subject = "Scheikunde",
        subject = "Verbranding",
        learned = "",
        requested_topics = "",
    }) {
        this.test = test
        this.id = id
        this.school_type = school_type
        this.school_year = school_year
        this.school_subject = school_subject
        this.subject = subject
        this.learned = learned
        this.requested_topics = requested_topics
    }
    get request_text() {
        return `
                Je moet een toets gaan genereren op het juiste niveau.
                School Type: ${this.school_type}
                School Jaar: ${this.school_year}
                Vak: ${this.school_subject}
                Onderwerp(en): ${this.subject}

                Nu krijg je wat informatie over wat er in de toets moet komen en wat je de leerlingen kan vragen.
                Geleerde stof: ${this.learned}
                Door de docent aangevraagde onderwerpen die op de toets komen: ${this.requested_topics}

                Geef de vragen in het aangegeven schema
                        vraag tekstQ: de exacte tekst van de vraag
                        question_number: dit is het nummer van de vraag, oftewel vraagnummer.
                        question_context: is de tekst die voor een vraag staat om de situatie te schetsen of de vraag in te leiden, dit is niet altijd nodig
                        is_draw_question: geeft aan of het antwoord bij deze vraag het antwoord geen puur tekstantwoord is
                        points: Haal uit de rubric bij elke vraag de rubric punten, als er geen punten in de rubric staan moet je zelf punten bedenken.
                een vraag heeft 1-3 punten en elk punt heeft:
                        een naam (point_name) met in 1 of 2 woorden waar die punt overgaat
                        een tekst (point_text) met daarin de exacte uitleg van dit punt
                        een nummber (point_index) welk punt dit is, bij deze vraag, start bij 0
                        een gewicht (point_weight) voor hoeveel punten deze rubricpoint mee telt
                        leerdoel (target_name) het leerdoel waar dit punt bij hoort
                
                Daarmaast moet je bij de hele toets een paar overkoepelende leerdoelen bedenken.
                Elk leerdoel heeft een korte naam: dit is ook de naam die bij elk punt waar dit leerdoel het meest bij hoort wordt ingevuld
                en een uitleg (explanation) met daarin exact wat dit leerdoel inhoud.

                Voor de vraag teksten mag je markdown gebruiken 
                Ook kan je dollar tekens gebruiken om latex equations te laten zien
                niewe regels ook toegestaan bij bijvoorbeeld meerkeuzevragen of een opsomming van dingen die een leerling moet beantwoorden.
                ook zijn nieuwe regels in de context toegestaan.

                De punten moeten heel duidelijk beschrijven wat een leerling precies moet hebben gedaan om het punt te verdienen. 
                Er mag geen twijfel over mogelijk zijn.
                Zet er zo nodig uitzonderingen bij

                geeft de resultaten in de taal van de gegeven toets(vaak zal dat Nederlands zijn)
                
                Houd je altijd aan het gegeven schema

                `
    }
}

class TestPdfSettings {
    constructor({
        test_name = "",
        show_targets = true,
        show_answers = false,
        output_type = 'docx'
    }) {
        this.test_name = test_name
        this.show_targets = show_targets
        this.show_answers = show_answers
        this.output_type = output_type
    }

}

class Test {
    constructor({
        id = getRandomID(),

        files = {
            test: {
                raw: null,
                blob: null,
                data: [],
            },
            rubric: {
                raw: null,
                blob: null,
                data: [],
            },
            students: {
                raw: null,
                blob: null,
                data: [],
            },
        },
        questions = [],
        students = [],
        targets = [],
        pages = [],

        test_data_result = null,
        gpt_test = new GptTestSettings({}),
        gpt_question = new GptQuestionSettings({}),
        test_settings = new TestPdfSettings({}),

        gpt_provider = "google",
        gpt_model = "gemini-2.0-flash",
        grade_rules = "",
    }) {
        this.id = id
        this.files = files

        this.pages = pages

        this.questions = questions.map(e => new Question({
            test: this,
            ...e
        }))
        this.students = students.map(e => new Student({
            test: this,
            ...e
        }))
        this.targets = targets.map(e => new Target({
            test: this,
            ...e
        }))
        this.test_data_result = test_data_result

        this.test_settings = test_settings


        this.saved_section_data = []
        this.saved_student_data = []
        this.saved_grade_data = {}
        this.saved_output = {
            questions: [],
            targets: []
        }
        this.gpt_test = gpt_test
        this.gpt_test.test = this
        this.gpt_question = gpt_question
        this.gpt_question.test = this
        this.loading = {
            pdf_data: false,
            structure: false,
            sections: false,
            students: false,
            grading: false,
            test_pdf: false

        }

        this.gpt_provider = gpt_provider
        this.gpt_model = gpt_model
        this.grade_rules = grade_rules

    }
    get modelConfig (){
        return {
            google: {
                "gemini-2.0-pro-exp-02-05": {
                    test_recognition: "nieuw, zeer langzaam en werkt soms",
                    test_generation: "nieuw, zeer langzaam en werkt soms",
                    text_recognition: "nieuw, zeer langzaam en werkt soms",
                    grading: "nieuw, zeer langzaam en werkt soms",
                },
                "gemini-2.0-flash": {
                    test_recognition: "snel, nieuw en geeft soms error",
                    test_generation: "snel, nieuw en geeft soms error",
                    text_recognition: "snel, nieuw en geeft soms error",
                    grading: "snel, nieuw en geeft soms error",
                },
                "gemini-1.5-pro": {
                    test_recognition: "prima, maar oud",
                    test_generation: "prima, maar oud",
                    text_recognition: "prima, maar oud",
                    grading: "prima, maar oud",
                },
                "learnlm-1.5-pro-experimental": {
                    test_recognition: "gemaakt voor feedback leerling, maar oud",
                    test_generation: "gemaakt voor feedback leerling, maar oud",
                    text_recognition: "gemaakt voor feedback leerling, maar oud",
                    grading: "gemaakt voor feedback leerling, maar oud",
                },
                "gemini-exp-1206": {
                    test_recognition: "pro 2.0, werkt meestal",
                    test_generation: "pro 2.0, werkt meestal",
                    text_recognition: "pro 2.0, werkt meestal",
                    grading: "pro 2.0, werkt meestal",
                }
            },
            openai: {
                "gpt-4o-mini": {
                    test_recognition: "oud, werkt voor fotoherkenning",
                    test_generation: "oud, werkt voor fotoherkenning",
                    text_recognition: "oud, werkt voor fotoherkenning",
                    grading: "oud, werkt voor fotoherkenning",
                },
                "gpt-4o": {
                    test_recognition: "duur",
                    test_generation: "duur",
                    text_recognition: "duur",
                    grading: "duur",
                },
                "gpt-o3-mini": {
                    test_recognition: "nieuw o3 model",
                    test_generation: "nieuw o3 model",
                    text_recognition: "nieuw o3 model",
                    grading: "nieuw o3 model",
                },
            },
            deepseek: {
                "deepseek-chat": {
                    test_recognition: "oude deepseek model, kan lever rare resultaten op",
                    test_generation: "oude deepseek model, kan lever rare resultaten op",
                    text_recognition: "oude deepseek model, kan lever rare resultaten op",
                    grading: "oude deepseek model, kan lever rare resultaten op",
                },
                "deepseek-reasoner": {
                    test_recognition: "r1",
                    test_generation: "r1",
                    text_recognition: "r1",
                    grading: "r1",
                }
            },
            alibaba: {
                "qwen-turbo": {
                    test_recognition: "snel, maar onvoorspelbaar",
                    test_generation: "snel, maar onvoorspelbaar",
                    text_recognition: "snel, maar onvoorspelbaar",
                    grading: "snel, maar onvoorspelbaar",
                },
                "qwen-plus": {
                    test_recognition: "prima",
                    test_generation: "prima",
                    text_recognition: "prima",
                    grading: "prima",
                },
                "qwen-max-2025-01-25": {
                    test_recognition: "nieuwste, werkt goed, geeft lange resultaten",
                    test_generation: "nieuwste, werkt goed, geeft lange resultaten",
                    text_recognition: "nieuwste, werkt goed, geeft lange resultaten",
                    grading: "nieuwste, werkt goed, geeft lange resultaten",
                },
                "qwen-max": {
                    test_recognition: "werkt ook goed",
                    test_generation: "werkt ook goed",
                    text_recognition: "werkt ook goed",
                    grading: "werkt ook goed",
                }
            }
        };
    }
    get providerModels() {
        return Object.keys(this.modelConfig).reduce((data, model) => {
            data[model] = Object.keys(this.modelConfig[model])
            return data
        }, {})
        
    }
    get total_model_count() {
        return sum(Object.values(this.providerModels).map(e => e.length))
    }
    gpt_models(action) {



        if (this.modelConfig[this.gpt_provider]) {
            return Object.keys(this.modelConfig[this.gpt_provider]).map(model => {
                return {
                    value: model,
                    title: model + '(' + (this.modelConfig[this.gpt_provider][model]?. [action] || '') + ')'
                }
            })
        }
        return []

    }
    get is_loading() {
        return Object.values(this.loading).some(e => e)
    }
    get total_points() {
        return sum(this.questions.map(q => q.total_points))
    }
    get student_pdf_data() {
        return this.students.map(e => e.result_pdf_data)
    }
    setQuestionNumbers() {
        this.questions.forEach((question, index) => {
            question.question_number = (index + 1).toString()
        })
    }
    async loadDataFromPdf(field_type) {
        this.loading.pdf_data = true
        console.log(field_type)
        if (["rubric", "test"].includes(field_type)) {
            this.files[field_type].data = await globals.$extractTextAndImages(this.files[field_type].raw)

        } else if (["load_pages", "students"].includes(field_type)) {
            this.students.data = await globals.$pdfToBase64Images(this.files["students"].raw)

            this.students.data.forEach(page => {
                this.addPage(page)
            })
        }
        this.loading.pdf_data = false
    }
    async generateGptTest() {
        this.loading.structure = true
        const request_text = this.gpt_test.request_text


        try {

            var result = await apiRequest('/gpt-test', {
                requestText: request_text,
                model: this.gpt_model,
                provider: this.gpt_provider
            })
            console.log(result)
        } catch (error) {
            console.log(error)
            this.loading.structure = false

            return
        }

        // var result = {result: {
        //         "questions": [
        //                 {
        //                         "is_draw_question": false,
        //                         "points": [
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 0,
        //                                         "point_name": "Formule opstellen",
        //                                         "point_text": "De leerling kan de juiste formule opstellen.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Formulegebruik"
        //                                 },
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 1,
        //                                         "point_name": "Sinus toepassen",
        //                                         "point_text": "De leerling past de sinus correct toe in de formule.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Wiskundige vaardigheden"
        //                                 },
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 2,
        //                                         "point_name": "Eenheden",
        //                                         "point_text": "De leerling gebruikt de juiste eenheden.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Eenheden"
        //                                 }
        //                         ],
        //                         "question_context": "Een massa hangt aan een veer. De uitwijking $u$ van de massa ten opzichte van de evenwichtsstand wordt gegeven door de formule: $u = A \\cdot \\sin(2\\pi ft)$",
        //                         "question_number": "1",
        //                         "question_text": "De amplitude $A$ is 0,1 m, de frequentie $f$ is 2 Hz en de tijd $t$ is 0,5 s. Bereken de uitwijking $u$."
        //                 },
        //                 {
        //                         "is_draw_question": false,
        //                         "points": [
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 0,
        //                                         "point_name": "Formule opstellen",
        //                                         "point_text": "De leerling kan de juiste formule opstellen.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Formulegebruik"
        //                                 },
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 1,
        //                                         "point_name": "Wortel toepassen",
        //                                         "point_text": "De leerling past de wortel correct toe in de formule.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Wiskundige vaardigheden"
        //                                 },
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 2,
        //                                         "point_name": "Eenheden",
        //                                         "point_text": "De leerling gebruikt de juiste eenheden.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Eenheden"
        //                                 }
        //                         ],
        //                         "question_context": "De snelheid $v$ van een golf in een snaar wordt gegeven door de formule: $v = \\sqrt{\\frac{F}{\\mu}}$",
        //                         "question_number": "2",
        //                         "question_text": "De spankracht $F$ in de snaar is 100 N en de massa per lengte-eenheid $\\mu$ is 0,1 kg/m. Bereken de snelheid $v$ van de golf."
        //                 },
        //                 {
        //                         "is_draw_question": false,
        //                         "points": [
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 0,
        //                                         "point_name": "Tabel lezen",
        //                                         "point_text": "De leerling kan de juiste waarden uit de tabel aflezen.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Tabellen"
        //                                 },
        //                                 {
        //                                         "has_point": true,
        //                                         "point_index": 1,
        //                                         "point_name": "Formule toepassen",
        //                                         "point_text": "De leerling past de formule correct toe.",
        //                                         "point_weight": 1,
        //                                         "target_name": "Formulegebruik"
        //                                 }
        //                         ],
        //                         "question_context": "In de tabel hieronder staan de waarden voor de sinus van een aantal hoeken.\n\n| Hoek (graden) | sin(hoek) |\n|---|---|\n| 0 | 0 |\n| 30 | 0,5 |\n| 45 | 0,71 |\n| 60 | 0,87 |\n| 90 | 1 |\n\nDe uitwijking $u$ van een trillend voorwerp wordt gegeven door de formule $u = A \\cdot \\sin(\\alpha)$, waarbij $A$ de amplitude is en $\\alpha$ de hoek in graden.",
        //                         "question_number": "3",
        //                         "question_text": "De amplitude $A$ is 5 cm. Wat is de uitwijking $u$ bij een hoek van 30 graden?"
        //                 }
        //         ],
        //         "targets": [
        //                 {
        //                         "explanation": "De leerling kan formules met sinussen en wortels toepassen in verschillende contexten.",
        //                         "target_name": "Formulegebruik"
        //                 },
        //                 {
        //                         "explanation": "De leerling kan wiskundige bewerkingen zoals het berekenen van een sinus en een wortel correct uitvoeren.",
        //                         "target_name": "Wiskundige vaardigheden"
        //                 },
        //                 {
        //                         "explanation": "De leerling kan de juiste eenheden gebruiken bij het toepassen van formules.",
        //                         "target_name": "Eenheden"
        //                 },
        //                 {
        //                         "explanation": "De leerling kan informatie uit tabellen aflezen en gebruiken in berekeningen.",
        //                         "target_name": "Tabellen"
        //                 }
        //         ]
        // }}

        if (!result.result) {
            this.loading.structure = false

            return
        }


        this.test_data_result = result.result
        this.loadTestData()
        console.log('loadTestStructure: ', result, '\n Test: ', this)
        this.loading.structure = false
    }
    async generateGptQuestion() {
        this.loading.structure = true
        const request_text = this.gpt_question.request_text


        try {

            var result = await apiRequest('/gpt-test-question', {
                requestText: request_text,
                model: this.gpt_model,
                provider: this.gpt_provider
            })
            console.log(result)

        } catch (error) {
            console.log(error)
            this.loading.structure = false

            return
        }

        //         var result = {result: {
        // "questions": [
        //         {
        //                 "is_draw_question": false,
        //                 "points": [
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 0,
        //                                 "point_name": "Reactanten",
        //                                 "point_text": "Methaan en zuurstof staan voor de pijl",
        //                                 "point_weight": 1,
        //                                 "target_name": "Reactievergelijkingen"
        //                         },
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 1,
        //                                 "point_name": "Producten",
        //                                 "point_text": "Koolstofdioxide en water staan na de pijl",
        //                                 "point_weight": 1,
        //                                 "target_name": "Reactievergelijkingen"
        //                         },
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 2,
        //                                 "point_name": "Kloppend",
        //                                 "point_text": "De reactievergelijking is kloppend gemaakt",
        //                                 "point_weight": 1,
        //                                 "target_name": "Reactievergelijkingen"
        //                         }
        //                 ],
        //                 "question_context": "Bij een volledige verbranding van een brandstof reageert de brandstof met zuurstof. Hierbij ontstaan een of meerdere verbrandingsproducten.",
        //                 "question_number": "1",
        //                 "question_text": "Wat is de reactievergelijking van de volledige verbranding van methaan (CH4)?"
        //         },
        //         {
        //                 "is_draw_question": false,
        //                 "points": [
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 0,
        //                                 "point_name": "Antwoord",
        //                                 "point_text": "Koolstofmono-oxide of roet",
        //                                 "point_weight": 1,
        //                                 "target_name": "Volledige en onvolledige verbranding"
        //                         }
        //                 ],
        //                 "question_context": "Bij een onvolledige verbranding is er te weinig zuurstof aanwezig voor een volledige verbranding.",
        //                 "question_number": "2",
        //                 "question_text": "Welke stof kan er ontstaan bij een onvolledige verbranding die niet ontstaat bij een volledige verbranding?"
        //         },
        //         {
        //                 "is_draw_question": false,
        //                 "points": [
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 0,
        //                                 "point_name": "Nadeel 1",
        //                                 "point_text": "Bij verbranding komt CO2 vrij, wat bijdraagt aan het versterkte broeikaseffect",
        //                                 "point_weight": 1,
        //                                 "target_name": "Fossiele brandstoffen"
        //                         },
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 1,
        //                                 "point_name": "Nadeel 2",
        //                                 "point_text": "Fossiele brandstoffen raken op",
        //                                 "point_weight": 1,
        //                                 "target_name": "Fossiele brandstoffen"
        //                         }
        //                 ],
        //                 "question_context": "Aardgas is een fossiele brandstof die veel gebruikt wordt in huishoudens.",
        //                 "question_number": "3",
        //                 "question_text": "Noem twee nadelen van het gebruik van fossiele brandstoffen."
        //         },
        //         {
        //                 "is_draw_question": false,
        //                 "points": [
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 0,
        //                                 "point_name": "Zuurstof",
        //                                 "point_text": "De hoeveelheid zuurstof in de ruimte neemt af",
        //                                 "point_weight": 1,
        //                                 "target_name": "Volledige en onvolledige verbranding"
        //                         },
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 1,
        //                                 "point_name": "Verbranding",
        //                                 "point_text": "De verbranding wordt onvollediger",
        //                                 "point_weight": 1,
        //                                 "target_name": "Volledige en onvolledige verbranding"
        //                         },
        //                         {
        //                                 "has_point": true,
        //                                 "point_index": 2,
        //                                 "point_name": "Vlam",
        //                                 "point_text": "De vlam wordt kleiner en zal uiteindelijk doven",
        //                                 "point_weight": 1,
        //                                 "target_name": "Volledige en onvolledige verbranding"
        //                         }
        //                 ],
        //                 "question_context": "Een kaars brandt in een afgesloten ruimte.",
        //                 "question_number": "4",
        //                 "question_text": "Leg uit wat er gebeurt met de vlam van de kaars naarmate de tijd verstrijkt."
        //         }
        // ],
        // "targets": [
        //         {
        //                 "explanation": "De leerling kan reactievergelijkingen van verbrandingsreacties opstellen en kloppend maken.",
        //                 "target_name": "Reactievergelijkingen"
        //         },
        //         {
        //                 "explanation": "De leerling begrijpt het verschil tussen volledige en onvolledige verbranding en kan de reactieproducten benoemen.",
        //                 "target_name": "Volledige en onvolledige verbranding"
        //         },
        //         {
        //                 "explanation": "De leerling kent de nadelen van het gebruik van fossiele brandstoffen.",
        //                 "target_name": "Fossiele brandstoffen"
        //         }
        // ]
        //         }}

        if (!result.result) {
            this.loading.structure = false

            return
        }


        this.addQuestion(result.result)
        console.log('loadTestQuestion: ', result, '\n Test: ', this)
        this.loading.structure = false
    }
    async loadTestStructure(use_preload = false) {
        this.loading.structure = true
        const request_text = `
                Je krijg een toets en de antwoorden. Jouw taak is om die zo goed en precies mogelijk in een digitaal formaat om te zetten.
                je hoeft niets te doen met de context om een vraag. Het gaat alleen om de vraag zelf
                Extraheer uit de teksten de vragen:
                        vraag tekst: de exacte tekst van de vraag
                        question_context: tekst die voor een vraag staat, het is niet altijd nodig
                        question_number: 
                                dit is het nummer van de vraag, oftewel vraagnummer, dit kan ook een samenstelling zijn van nummers en letters: 1a, 4c enz. Het is SUPER belangrijk dat dit bij ELKE vraag wordt gegeven.
                        is_draw_question: geeft aan of het antwoord bij deze vraag het antwoord geen puur tekstantwoord is
                        points: Haal uit de rubric bij elke vraag de rubric punten, als er geen punten in de rubric staan moet je zelf punten bedenken.
                elk punt heeft:
                        een naam (point_name) met in 1 of 2 woorden waar die punt overgaat
                        een tekst (point_text) met daarin de exacte uitleg van dit punt
                        een nummber (point_index) welk punt dit is, bij deze vraag, start bij 0
                        een gewicht (point_weight) voor hoeveel punten deze rubricpoint mee telt
                        leerdoel (target_name) het leerdoel waar dit punt bij hoort
                
                Daarmaast moet je bij de hele toets een paar overkoepelende leerdoelen bedenken.
                Elk leerdoel heeft een korte naam: dit is ook de naam die bij elk punt waar dit leerdoel het meest bij hoort wordt ingevuld
                en een uitleg (explanation) met daarin exact wat dit leerdoel inhoud.


                geeft de resultaten in de taal van de gegeven toets(vaak zal dat Nederlands zijn)

                de question_number bij de vragen moet bij elke vraag aanwezig zijn

                Houd je altijd aan het gegeven schema

                Hier volgt de toets:
                        
                `

        const test_data = this.files.test.data
        const rubric_data = this.files.rubric.data

        if (use_preload) {

            var result = {
                result: this.saved_output
            }
        } else {


            var result = await apiRequest('/test-data', {
                requestText: request_text,
                testData: {
                    toets: test_data,
                    rubric: rubric_data
                }
            })
        }

        if (!result.result) {
            return
        }


        this.test_data_result = result.result


        console.log('loadTestStructure: ', result)
        this.loadTestData()
        this.loading.structure = false
    }
    async downloadTest() {
        this.loading.test_pdf = true

        const test_data = {
            questions: [],
            targets: [],
            settings: this.test_settings
        }

        this.questions.forEach(question => {
            test_data.questions.push({
                question_number: question.question_number,
                question_text: question.question_text,
                question_context: question.question_context,
                answer_text: question.answer_text,
                points: question.points.map(point => {
                    return {
                        point_name: point.point_name,
                        point_text: point.point_text,
                        point_index: point.point_index,
                        point_weight: point.point_weight,
                        target_name: point.target_name
                    }
                }),
            })
        })
        this.targets.forEach(target => {
            test_data.targets.push({
                target_name: target.target_name,
                explanation: target.explanation
            })
        })

        await downloadTest(test_data)
        console.log(test_data)
        this.loading.test_pdf = false

    }
    loadTestData() {
        this.targets = []

        this.test_data_result.targets?.forEach(e => {
            this.addTarget(e)
        })
        console.log(this.test_data_result)
        this.questions = []

        this.test_data_result.questions?.forEach((e, index) => {
            if (!e.question_number) {
                e.question_number = (index + 1).toString()
            }
            this.addQuestion(e)
        })
    }
    addTarget(target) {


        this.targets.push(new Target({
            test: this,
            ...target
        }))
    }
    addQuestion(question) {
        if (question.question_number) {

            this.questions.push(new Question({
                test: this,
                ...question,
            }))
        } else {
            console.log('Could not find question id for: ', question)
        }
    }
    createPages() {
        this.files.students.data.forEach(image => {
            this.addPage(image)
        })
    }
    get test_context() {
        return new ContextData({
            questions: this.questions.reduce((data, e) => {
                data[e.question_number] = e.question_text
                return data
            }, {}),
            rubrics: this.questions.reduce((data, e) => {
                data[e.question_number] = e.points.map(e => e.point_text).join("\n")
                return data
            }, {}),
        })
    }

    addPage(base64Image) {


        // TODO: fix the ScanPage
        this.pages.push(new ScanPage(base64Image, this.test_context))
    }
    async loadStudentIds() {
        await Promise.all(this.pages.map(async (page, index) => {
            return this.pages[index].detectStudentId()
        }))
    }
    async loadSections() {
        await Promise.all(this.pages.map(async (page, index) => {
            return this.pages[index].loadSections(false)
        }))


        const base64_sections = this.pages.map(page => page.sections.map(section => section.question_selector || "")).flat(Infinity)

        const response = await apiRequest('/question_selector_info', {
            "base64Images": JSON.stringify(base64_sections),
            "checkbox_count": "7"
        })

        if (response.length != base64_sections.length) {
            console.log('Page: ExtractQuestionLengthError: response: ', response.length, '- sections:', this.sections.length, response)
            this.loading.create_question = false
            return
        } else {
            console.log('Page: Extract question number result: ', response)

        }
        var image_index = -1
        for (let index = 0; index < this.pages.length; index++) {
            for (let section_index = 0; section_index < this.pages[index].sections.length; section_index++) {
                image_index += 1
                if (!!response[image_index].selected_checkbox && response[image_index].selected_checkbox > 0) {
                    this.pages[index].sections[section_index].question_number = response[image_index].selected_checkbox
                    return
                }
                this.pages[index].sections[section_index].question_number = 0

            }
        }


    }

    async scanStudentIdsAndSections(use_preloaded = false) {
        this.loading.sections = true
        // const preload = []
        // await Promise.all(this.pages.map(async (page, index) => {
        if (!use_preloaded) {

            await this.loadStudentIds()


            await this.loadSections()
        }
        for (let index = 0; index < this.pages.length; index++) {


            if (use_preloaded) {
                console.log(this.saved_section_data[index])
                this.pages[index].student_id = this.saved_section_data[index].student_id || ""

                this.pages[index].sections = this.saved_section_data[index].sections.map(e => {
                    return new ScanSection({
                        ...e,
                        student_id: this.pages[index].student_id
                    })
                })
            } else {
                // temp_section_data.push({
                //         student_id: this.pages[index].student_id,
                //         sections: this.pages[index].sections
                // })
                // console.log('preload: ', temp_section_data)
            }
        }
        // }))


        this.loading.sections = false

    }
    async loadStudents(use_preload = false) {
        this.loading.students = true

        if (use_preload) {
            this.saved_student_data.forEach(student_data => {
                const student = new Student({
                    test: this,
                    student_id: student_data.student_id
                })

                this.questions.forEach(question => {
                    const result = student_data.results.find(e => e.scan?.question_number == question.question_number)
                    const question_result = new StudentQuestionResult({
                        student: student,
                        question_id: question.id,
                        // conversion mistake
                        scan: result?.scan?.base64Image,
                        student_handwriting_percent: result?.student_handwriting_percent

                    })

                    question_result.resetPoints()

                    student.results.push(question_result)
                })

                this.students.push(student)

            })
            this.students.sort((a, b) => Number(a.student_id) - Number(b.student_id))
            this.loading.students = false

            return

        }
        const unique_student_ids = [...new Set(this.pages.map(e => e.student_id))].filter(e => e).sort((a, b) => Number(a) - Number(b))
        console.log(unique_student_ids)

        const test_context = this.test_context

        // await Promise.all(unique_student_ids.map(async student_id => {
        for (var student_id in unique_student_ids) {
            var student_id = unique_student_ids[student_id]
            const student_pages = this.pages.filter(e => e.student_id == student_id)

            var student_sections = []

            student_pages.forEach(page => {
                student_sections = student_sections.concat(page.sections)
            });

            var scan_questions = await Promise.all(this.questions.map(async question => {
                const question_sections = student_sections.filter(section => section.question_number.toString() == question.question_number.toString())
                if (question_sections.length == 0) {
                    return {
                        success: false,
                        question_id: question.id
                    }

                }
                const response = await apiRequest('/link_answer_sections', {
                    sections: question_sections.map(section => section.answer),
                })

                if (!response || response.error) {
                    return {
                        success: false,
                        question_id: question.id
                    }
                }

                const scan_question = new ScanQuestion({
                    base64Image: response,
                    question_number: question.question_number
                })

                await scan_question.extractText(test_context, this.gpt_provider, this.gpt_model)

                return {
                    success: true,
                    question_id: question.id,
                    scan_question,
                    student_handwriting_percent: response.student_handwriting_percent
                }
            }))

            const student = new Student({
                test: this,
                student_id: student_id,
            })

            scan_questions.forEach(scan_question => {

                const question_result = new StudentQuestionResult({
                    student: student,
                    question_id: scan_question.question_id,
                    scan: scan_question.success ? scan_question.scan_question : undefined,
                    student_handwriting_percent: scan_question.student_handwriting_percent
                })
                question_result.resetPoints()

                student.results.push(question_result)
            })
            console.log(student_id, student)

            const index = this.students.findIndex(e => e.student_id == student.student_id)
            if (index == -1) {
                this.students.push(student)

            } else {
                this.students[index] = student
            }

        }
        // }))

        // print preload
        console.log(this.students.map(student => {
            return {
                student_id: student.student_id,
                results: student.results.map(result => {
                    return {
                        question_number: result.question_number,
                        scan: {
                            base64Image: result.scan,
                            text: result.scan.text,
                            question_number: result.scan.question_number,
                        },
                        student_handwriting_percent: result.student_handwriting_percent
                    }
                })
            }
        }))

        this.loading.students = false
    }
    async gradeStudents(use_preload = false) {
        this.loading.grading = true
        // await Promise.all(this.students.map(e => e.grade(use_preload)))
        for (let i = 0; i < this.students.length; i++) {
            await this.students[i].grade(use_preload)

        }
        this.loading.grading = false
    }
    async downloadStudentResults(feedback_field = false) {
        await downloadResultPdf(this.student_pdf_data, feedback_field, 'AlleResultaten')
    }
    async loadPreload() {
        const [
            saved_section_data,
            saved_student_data,
            saved_grade_data,
            saved_output
        ] = await Promise.all([
            import('/src/saved_section_data2.json').then(module => module.default),
            import('/src/saved_student_data.json').then(module => module.default),
            import('/src/saved_grade_data.json').then(module => module.default),
            import('/src/saved_output.json').then(module => module.default),
        ])
        this.saved_section_data = saved_section_data
        this.saved_student_data = saved_student_data
        this.saved_grade_data = saved_grade_data
        this.saved_output = saved_output
    }



}


class Question {
    constructor({
        test = new Test({}),
        id = getRandomID(),
        question_number = "",
        question_text = "",
        question_context = "",
        answer_text = "",
        is_draw_question = false,
        points = [],
    }) {
        this.test = test
        this.is_draw_question = is_draw_question
        this.id = id
        this.question_number = question_number
        this.question_context = question_context
        this.question_text = question_text
        this.answer_text = answer_text
        this.points = []

        points.forEach(e => this.addRubricPoint(e))
    }
    get total_points() {
        return sum(this.points.map(point => point.point_weight))
    }
    addRubricPoint(point) {
        const target = this.test.targets.find(e => e.target_name == point.target_name)


        this.points.push(new RubricPoint({
            question: this,
            ...point,
            target
        }))
    }
}

class RubricPoint {
    constructor({
        question = new Question({}),
        id = getRandomID(),
        point_text = "",
        point_name = "",
        point_weight = 1,
        point_index = 0,
        target = new Target({}),
        target_id = null
    }) {
        this.question = question

        this.id = id
        this.point_index = point_index
        this.point_text = point_text
        this.point_name = point_name
        this.point_weight = point_weight
        this.target_id = target_id || target.id
    }
    get target() {
        return this.question.test.targets.find(e => e.id == this.target_id)
    }
}

class Target {
    constructor({
        test = new Test({}),
        id = getRandomID(),
        target_name = "",
        explanation = "",
    }) {
        this.test = test

        this.id = id
        this.target_name = target_name
        this.explanation = explanation
    }
    get average_received_points() {
        return Math.round(sum(this.test.students.map(student => sum(student.results.map(q_result => sum(Object.values(q_result.point_results).filter(p_result => p_result.point.target_id == this.id).filter(p_result => p_result.has_point).map(p_result => p_result.point.point_weight)))))) / this.test.students.length * 1000) / 1000
    }
    get total_points() {
        return sum(this.test.questions.map(q => sum(q.points.filter(e => e.target_id == this.id).map(e => e.point_weight))))
    }
    get percent() {
        return (this.average_received_points / this.total_points * 100).toFixed(1) + '%'
    }
}

class Student {
    constructor({
        test = new Test({}),
        id = getRandomID(),
        student_id = "",
        results = [],
        is_grading = false,
    }) {
        this.test = test
        this.id = id
        this.student_id = student_id
        this.results = results.map(e => new StudentQuestionResult({
            student: this,
        }))
        this.results.forEach((e, index) => this.results[index].resetPoints())
        this.is_grading = is_grading
    }

    get target_results() {
        const target_results = {}
        this.test.targets.forEach(target => {
            var total_points = 0
            var received_points = 0

            this.test.questions.forEach(question => {
                question.points.forEach(point => {
                    if (point.target_id == target.id) {
                        total_points += 1

                        const question_result = this.results.find(e => e.question_id == question.id)
                        if (question_result) {

                            const point_result = question_result.point_results[point.point_index]
                            if (point_result) {
                                if (point_result.has_point) {
                                    received_points += point.point_weight
                                }
                            }
                        }
                    }
                })
            })

            target_results[target.id] = {
                total_points: total_points,
                received_points: received_points,
                percent: (received_points / total_points * 100).toFixed(1) + '%',
                target: target,
            }
        })
        return target_results
    }
    get question_results() {
        const question_results = {}
        this.test.questions.forEach(question => {
            var total_points = 0
            var received_points = 0

            const result = this.results.find(e => e.question_id == question.id)
            if (result) {
                question.points.forEach(point => {
                    total_points += 1

                    const point_result = result.point_results[point.point_index]
                    if (point_result) {
                        if (point_result.has_point) {
                            received_points += point.point_weight
                        }
                    }
                })
            }


            question_results[question.id] = {
                total_points: total_points,
                received_points: received_points,
                percent: (received_points / total_points * 100).toFixed(1) + '%',
                result: result,
                question: question,
            }
        })
        return question_results
    }

    get received_points() {
        return sum(Object.values(this.question_results).map(e => e.received_points))
    }
    get result_pdf_data() {
        return {
            student_id: this.student_id,
            question_results: Object.values(this.question_results).map(question_result => {
                return {
                    question_number: question_result.question.question_number,
                    student_answer: question_result.result.scan.text,
                    feedback: question_result.result.feedback,
                    score: `${question_result.received_points} / ${question_result.total_points}`,
                    points: Object.values(question_result.result.point_results).map(point_result => {
                        return {
                            point_name: point_result.point.point_name,
                            points: point_result.has_point ? point_result.point.point_weight : 0,
                            feedback: point_result.feedback.length > 0 ? point_result.feedback : 'Geen feedback',
                        }
                    }),
                }
            }),
            targets: Object.values(this.target_results).map(target_result => {
                return {
                    target_name: target_result.target.target_name,
                    explanation: target_result.target.explanation,
                    score: `${target_result.received_points} / ${target_result.total_points}`,
                    percent: target_result.percent,
                }

            })
        }
    }
    async grade(use_preload = false) {
        this.is_grading = true
        await Promise.all(this.results.map(async question_result => {
            await question_result.grade(use_preload)
        }))
        console.log('Temp: ', temp_saved_grade_data)


        this.is_grading = false
    }
    async downloadStudentResult(feedback_field = false) {
        console.log('Starting download: ')
        await downloadResultPdf([this.result_pdf_data], feedback_field, 'LeerlingResultaat_' + this.student_id)
    }


}

class StudentQuestionResult {
    constructor({
        id = getRandomID(),
        student = new Student({}),
        question_id = "",
        feedback = "",
        point_results = {},
        scan = new ScanQuestion({}),
        is_grading = false,
        student_handwriting_percent = 0
    }) {
        this.id = id
        this.student = student
        this.question_id = question_id
        this.feedback = feedback
        this.point_results = point_results
        this.scan = new ScanQuestion(scan)
        this.is_grading = is_grading
        this.student_handwriting_percent = student_handwriting_percent

    }
    get question() {
        return this.student.test.questions.find(e => e.id == this.question_id) || new Question({})
    }
    resetPoints() {
        this.point_results = {}
        this.question.points.forEach(point => {
            this.point_results[point.point_index] = new StudentPointResult({
                student_result: this,
                point_index: point.point_index
            })
        })
    }
    async grade(use_preload = false) {
        this.is_grading = true

        if ((!this.question.is_draw_question && this.scan.text.length == 0) ||
            (this.question.is_draw_question && this.scan.base64Image.length == 0)
        ) {
            console.log('No answer found for: student ', this.student.student_id, ' question: ', this.question.question_number)
            return
        }

        const context = this.student.test.test_context

        if (use_preload) {
            if (this.student.test.saved_grade_data[this.student.student_id]?. [this.question.question_number]) {
                var response = this.student.test.saved_grade_data[this.student.student_id]?. [this.question.question_number]
            }
        } else {
            // if (this.question.is_draw_question){
            //         var model = "gemini-2.0-flash-exp"
            //         var provider = "google"
            // }



            var response = await apiRequest('/grade', {
                gradeRules: this.student.test.grade_rules,
                rubric: context.getRubric(this.question.question_number),
                question: context.getQuestion(this.question.question_number),
                answer: this.question.is_draw_question ? "" : this.scan.text,
                studentImage: this.question.is_draw_question ? this.scan.base64Image : undefined,
                model: this.student.test.gpt_model,
                provider: this.student.test.gpt_provider,
            })
            if (this.question.is_draw_question) {

                await delay(2000)
            }


        }
        if (!use_preload) {

            console.log('Graded: student ', this.student.student_id, '    question: ', this.question.question_number, ':', response)
        }
        if (response && response.result && response.result.points) {
            var lowest_point_index = 0
            const sorted_points_indecies = response.result.points.map(e => e.point_index).sort((a, b) => a - b)
            if (sorted_points_indecies.length > 0) {
                lowest_point_index = sorted_points_indecies[0]
            }

            if (!temp_saved_grade_data[this.student.student_id]) {
                temp_saved_grade_data[this.student.student_id] = {}
            }
            temp_saved_grade_data[this.student.student_id][this.question.question_number] = response

            this.feedback = response.result.feedback
            response.result.points.forEach(response_point => {
                // const index = this.points.findIndex(point => point.point.point_index = response_point.point_index)
                if (this.point_results[response_point.point_index - lowest_point_index]) {
                    this.point_results[response_point.point_index - lowest_point_index].has_point = response_point.has_point
                    this.point_results[response_point.point_index - lowest_point_index].feedback = response_point.feedback
                }
            })
        }

        this.is_grading = false
    }
}

class StudentPointResult {
    constructor({
        id = getRandomID(),
        student_result = new StudentQuestionResult({}),
        has_point = null,
        feedback = "",
        point_index = "",
    }) {
        this.id = id
        this.student_result = student_result
        this.has_point = has_point
        this.feedback = feedback
        this.point_index = point_index
    }
    get point() {
        return this.student_result.question.points.find(e => e.point_index == this.point_index) || new RubricPoint({})
    }
}









export {
    ScanPage,
    ScanSection,
    ScanQuestion,
    ContextData,


    Test,
    Question,
    RubricPoint,
    Target,
    Student,
    StudentQuestionResult,
    StudentPointResult,

}


# ======================
# File: src\tempCodeRunnerFile.js
# ======================

const

# ======================
# File: src\components\README.md
# ======================

# Components

Vue template files in this folder are automatically imported.

## ðŸš€ Usage

Importing is handled by [unplugin-vue-components](https://github.com/unplugin/unplugin-vue-components). This plugin automatically imports `.vue` files created in the `src/components` directory, and registers them as global components. This means that you can use any component in your application without having to manually import it.

The following example assumes a component located at `src/components/MyComponent.vue`:

```vue
<template>
  <div>
    <MyComponent />
  </div>
</template>

<script lang="ts" setup>
  //
</script>
```

When your template is rendered, the component's import will automatically be inlined, which renders to this:

```vue
<template>
  <div>
    <MyComponent />
  </div>
</template>

<script lang="ts" setup>
  import MyComponent from '@/components/MyComponent.vue'
</script>
```


# ======================
# File: src\components\full_view\MainLayout.vue
# ======================


<template lang="pug">
div(:style="{'height': $vuetify.display.mdAndUp ? '100vh' : 'calc(100dvh)', 'overflow-y': 'auto'}")

    NavigationDrawer(
        :test="test"
        :is_loading="is_loading"
    )
        SectionList(
            :selected_section_id="selected_section_id"
            :main_sections="main_sections"
            @update:selected_section_id="selected_section_id = $event"

        )


        template(v-slot:drawer2 v-if="selected_section.subsections.length > 0")
            SubsectionList(
                :selected_subsection_id="selected_section.selected_subsection_id"
                :subsections="selected_section.subsections"
                @update:selected_subsection_id="selected_section.selected_subsection_id = $event"
            )

    div.h-100
        RequestDialog(
            :active_requests="active_requests"

        )
        
        div.h-100(v-if="selected_section_id == 'test'")
            TestSection.h-100(
                :selected_subsection="selected_subsection"
                :test="test"
                v-model:selected_test_source="selected_test_source"
                @update:selected_test_source="selected_test_source = $event"
            )

        div.h-100(v-if="selected_section_id == 'scan'")
            ScanSection.h-100(
                :selected_subsection="selected_subsection"
                v-model:selected_student_id="selected_student_id"
                :test="test"
                v-model:selected_page_id="selected_page_id"
                @update:selected_page_id="selected_page_id = $event"
                @load-student-pages="loadStudentPages"
            )

        div.h-100(v-if="selected_section_id == 'grade'")
            GradeSection.h-100(
                :selected_subsection="selected_subsection"
                v-model:selected_student_id="selected_student_id"
                :test="test"
            )

        div.h-100(v-if="selected_section_id == 'analyze'")
            AnalyzeSection.h-100(
                :selected_subsection="selected_subsection"
                :test="test"
                v-model:selected_student_id="selected_student_id"
                v-model:is_generating_pdf="is_generating_pdf"
                v-model:self_feedback_field="self_feedback_field"
                @update:selected_student_id="selected_student_id = $event"
                @update:is_generating_pdf="is_generating_pdf = $event"
                @update:self_feedback_field="self_feedback_field = $event"
                @download-student-results="downloadStudentResults"
                @download-selected-result="downloadSelectedResult"
            )
</template>

<script>
import {
    Test
} from '@/scan_api_classes';
import NavigationDrawer from '@/components/full_view/NavigationDrawer.vue';
import SectionList from '@/components/full_view/SectionList.vue';
import SubsectionList from '@/components/full_view/SubsectionList.vue';
import TestSection from '@/components/full_view/TestSection/TestSection.vue';
import ScanSection from '@/components/full_view/ScanSection/ScanSection.vue';
import GradeSection from '@/components/full_view/GradeSection/GradeSection.vue';
import AnalyzeSection from '@/components/full_view/AnalyzeSection/AnalyzeSection.vue';
import RequestDialog from '@/components/full_view/RequestDialog.vue';
import {
    total_requests,
    rotateImage180,
    average,
    active_requests,
    apiRequest,
    downloadFileFromBase64,
    blobToBase64
} from '@/helpers';
import {
    imageToPngBase64
} from '@/helpers';
import test_example from '@/assets/test_example.pdf';
import rubric_example from '@/assets/rubric_example.pdf';
import toets_example from '@/assets/24-11-13_PWStoetsG3B.pdf'
import answer_print from '@/assets/answer_print.pdf'


export default {
    name: 'MainLayout',
    components: {
        NavigationDrawer,
        SectionList,
        SubsectionList,
        TestSection,
        ScanSection,
        GradeSection,
        AnalyzeSection,
        RequestDialog
    },
    setup() {
        return {
            total_requests,
            rotateImage180,
            average,
            active_requests,
            apiRequest
        }
    },
    data() {
        return {
            is_loading: false,
            currently_loading: "",
            main_sections: [
                {
                    name: 'Toets inladen',
                    id: 'test',
                    selected_subsection_id: 'structure',
                    subsections: [
                        {
                            name: "toets",
                            id: "test"
                        },
                        {
                            name: "rubric",
                            id: "rubric"
                        },
                        {
                            name: "ordenen",
                            id: "structure",
                            action: () => {
                                return this.selected_test_source == 'pdf' ? 'test_recognition' : 'test_generation'
                            }
                        },
                    ]
                },
                {
                    name: 'Inscannen',
                    id: 'scan',
                    selected_subsection_id: 'load_pages',
                    subsections: [
                        {
                            name: "Inladen",
                            id: "load_pages"
                        },
                        {
                            name: "Scannen",
                            id: "scan_pages"
                        },
                        {
                            name: "Leerlingen",
                            id: "generate_students",
                            action: () => {
                                return 'text_recognition'
                            }
                        },
                    ]
                },
                {
                    name: 'nakijken',
                    id: 'grade',
                    selected_subsection_id: 'grade_students',

                    subsections: [
                        // {
                        //     name: "Nakijken",
                        //     id: "grade_students",
                        //     action: () => {
                        //         return 'grading'
                        //     }

                        // }
                    ]
                },
                {
                    name: 'analyseer',
                    id: 'analyze',
                    selected_subsection_id: 'individual',

                    subsections: [
                        {
                            name: "Individueel",
                            id: "individual"
                        },
                        {
                            name: "Groep",
                            id: "group"
                        },

                    ]
                },
            ],
            selected_section_id: 'test',
            test: new Test({}),
            selected_page_id: '',
            selected_student_id: '',
            is_generating_pdf: false,
            self_feedback_field: false,
            selected_test_source: 'gpt',
            rerender_timer: true

        }
    },
    computed: {
        selected_section: {
            get() {
                return this.main_sections.find(e => e.id == this.selected_section_id)
            },
            set(val) {
                const index = this.main_sections.findIndex(e => e.id == val.id)

                if (index != -1) {
                    this.main_sections[index] = val
                }
            }
        },
        selected_student: {
            get() {
                return this.test.students.find(e => e.id == this.selected_student_id)
            },
            set(val) {
                const index = this.selected_student_index

                if (index != -1) {
                    this.test.students[index] = val
                }
            }
        },
        selected_student_index() {
            return this.test.students.findIndex(e => e.id == this.selected_student_id)
        },
        selected_subsection: {
            get() {
                return this.selected_section.subsections.find(e => e.id == this.selected_section.selected_subsection_id)
            },
            set(val) {
                const index = this.selected_section.subsections.findIndex(e => e.id == this.selected_section.selected_subsection_id)

                if (index != -1) {
                    this.selected_section.subsections[index] = val
                }
            }
        },
        action() {
            return this.selected_subsection?.action?.()

        },
        
    },
    methods: {
        log(s) {
            console.log(s)
        },
        async toDataURL(file) {
            console.log(file)
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = () => {
                    console.log("Loaded pdf file")
                    resolve(reader.result);
                };

                reader.onerror = () => {
                    reject(reader.error);
                };

                reader.readAsDataURL(file);
            });
        },
        base64ToBlob(base64String, contentType = '') {
            // Remove data URL prefix if it exists
            var base64Data = base64String.replace(/^data:([^;]+);base64,/, '');

            // Convert base64 to raw binary data
            var binaryData = atob(base64Data);

            // Create array buffer from binary data
            var arrayBuffer = new ArrayBuffer(binaryData.length);
            var uint8Array = new Uint8Array(arrayBuffer);

            // Fill array buffer with binary data
            for (let i = 0; i < binaryData.length; i++) {
                uint8Array[i] = binaryData.charCodeAt(i);
            }

            // Create blob from array buffer
            var blob = new Blob([arrayBuffer], {
                type: contentType
            });

            // Create and return blob URL
            return URL.createObjectURL(blob);
        },
        async loadBlob(filepath) {
            return new Promise((resolve, reject) => {
                // 1. Construct the full URL to the file within the site's directory.
                //    Assuming 'filepath' is relative to the current page or site's root.
                const fileUrl = new URL(filepath, window.location.href).href;

                // 2. Create a new XMLHttpRequest object to fetch the file.
                const xhr = new XMLHttpRequest();

                // 3. Configure the request:
                xhr.open('GET', fileUrl);
                xhr.responseType = 'blob'; // Tell the browser to expect a Blob as the response.

                // 4. Set up event listeners for successful load and errors.
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        resolve(xhr.response); // Resolve the promise with the Blob object.
                    } else {
                        reject(new Error(`Failed to load file: ${xhr.status} - ${xhr.statusText}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error("Network error occurred while fetching the file."));
                };

                // 5. Send the request.
                xhr.send();
            });
        },
        async loadStudentPages(event) {
            event.forEach(async file => {
                if (file.type.startsWith('image/')) {
                    const base64png = await imageToPngBase64(file)
                    if (base64png) {
                        this.test.files.students.data.push(base64png)
                        this.test.addPage(base64png)
                    }
                }
                if (file.type.startsWith('application/pdf')) {
                    this.test.files.students.raw = file
                    this.test.files.students.url = URL.createObjectURL(file)

                }
            })
        },
        printTest() {
            console.log(this.test.students.map(student => {
                return {
                    student_id: student.student_id,
                    results: student.results.map(result => {
                        return {
                            question_number: result.question_number,
                            scan: {
                                base64Image: result.scan,
                                text: result.scan.text,
                                question_number: result.scan.question_number,
                            },
                            student_handwriting_percent: result.student_handwriting_percent
                        }
                    })
                }
            }))
        },
        async downloadStudentResults() {
            this.is_generating_pdf = true
            // wait for component updates
            console.log(this.test.student_pdf_data)
            await this.test.downloadStudentResults(this.self_feedback_field)
            this.is_generating_pdf = false

        },
        async downloadSelectedResult() {
            this.is_generating_pdf = true
            // wait for component updates
            if (this.selected_student) {
                console.log(this.selected_student)

                await this.selected_student.downloadStudentResult(this.self_feedback_field)
            }
            this.is_generating_pdf = false

        },
        getGradeColor(percent) {

            if (percent < 0.55) {
                return 'rgba(255,100,100,' + (-percent + 0.55) + ')'

            }

            return 'rgba(100,255,100,' + (percent - 0.55) + ')'
        },
        async downloadAnswerSheet() {
            const pdf_blob = await this.loadBlob(answer_print)
            const base64_pdf = await blobToBase64(pdf_blob)
            downloadFileFromBase64(base64_pdf, 'AnswerSheetToetsPWS')
        },

        async loadPreload() {
            this.is_loading = true

            this.currently_loading = 'Downloading pdfs'
            try {
                var [
                    test_blob,
                    rubric_blob,
                    student_blob,
                    preload_result
                ] = await Promise.all([
                    this.loadBlob(test_example),
                    this.loadBlob(rubric_example),
                    this.loadBlob(toets_example),
                    this.test.loadPreload(),
                ]);

                this.currently_loading = 'Starting blobs'
                // 


                this.currently_loading = 'test and rubric pdf data'
                this.test.files.test.raw = test_blob
                this.test.files.test.url = URL.createObjectURL(test_blob) //await this.toDataURL(test_blob)
                await this.test.loadDataFromPdf('test')
                this.test.files.rubric.raw = rubric_blob
                this.test.files.rubric.url = URL.createObjectURL(rubric_blob) //await this.toDataURL(rubric_blob)
                await this.test.loadDataFromPdf('rubric')
                // 

                this.currently_loading = 'structure'
                await this.test.loadTestStructure(true)

                // 
                this.currently_loading = 'student PDF'

                this.test.files.students.raw = student_blob
                this.test.files.students.url = URL.createObjectURL(student_blob) //await this.toDataURL(student_blob)

                this.currently_loading = 'data from pdf'
                await this.test.loadDataFromPdf('students')

                this.currently_loading = 'Create pages'

                this.test.createPages()
                // 

                this.currently_loading = 'Starting loading student and sections'
                await this.test.scanStudentIdsAndSections(true)

                this.test.loadStudents(true)
                // console.log(this.printTest())
                this.currently_loading = 'Starting grading students'
                await this.test.gradeStudents(true)
                console.log(this.test)
                this.is_loading = false
            } catch (e) {
                this.currently_loading = 'Inladen gefaalt'
                console.log(e)
                setTimeout(() => {
                    this.is_loading = false
                }, 2000);

            }
        }

    },
    watch: {

    },
    // created() {

    // },
    async mounted() {
        setInterval(() => {
            this.rerender_timer = !this.rerender_timer
        }, 100);




    },
}
</script>
<style>

</style>

# ======================
# File: src\components\full_view\NavigationDrawer.vue
# ======================

// NavigationDrawer.vue
<template lang="pug">
v-navigation-drawer(
    v-if="isDesktop"
    permanent
    nav
    width="160"
)
    v-list
        v-btn(
            text="Laad preload (200MB)"
            @click="loadPreload()"
            :loading="test.loading.preload"
        )
        v-btn.mt-1(
            text="Download Antwoordpagina"
            @click="downloadAnswerSheet()"
        )
        v-btn.mt-1.w-100(
            text="Bekijk PWS"
            href="/pdf"
        )
        p Aantal modellen: {{ test.total_model_count }}
        v-select(
            :items='["google", "openai", "deepseek", "alibaba"]'
            v-model="test.gpt_provider"
            @update:modelValue="test.gpt_model = test.gpt_models(action)?.[0]?.value"
        )
        v-select(
            :items="test.gpt_models(action)"
            v-model="test.gpt_model"
            mandatory
        )
    slot
    v-navigation-drawer(
        permanent
        nav
        width="160"
        v-if="selected_section_id != 'analyze' && isDesktop && hasSlot('drawer2')"
    )
        v-list
            slot(name="drawer2")
v-progress-linear(
    v-if="isDesktop && (is_loading || test.is_loading)" 
    indeterminate 
    :style="{'position': 'absolute', 'top': 0, 'left': 0, 'z-index': 5}"
)
v-toolbar(
    v-if="!isDesktop"
    app
    color="primary"
    loading="true"
    dark
    density="compact"
    elevation="0"
    extension-height="0"
    fixed
    style="position: relative"
)
    
    template(#append)
        v-icon(icon="mdi-menu" @click.stop="drawer = !drawer") 

    v-toolbar-title
        .d-flex.flex-row.align-end
            h3 Toets PWS 
            p( style="font-size: 13px" v-if="Object.values(test.loading).filter(e => e).length > 0") Laden:
                i {{ Object.keys(test.loading).filter(e => test.loading[e]).join(",") }}
            p(v-else style="font-size: 13px" ) Site is in development
        
    template(#extension)
        v-progress-linear(
            color="white"
            v-if="is_loading || test.is_loading" 
            indeterminate 
        )
v-navigation-drawer(
    v-model="drawer"
    v-if="!isDesktop"
    temporary
    location="top"  
    height="auto"
)   
    v-btn.w-100(variant="text" @click="drawer = !drawer") Sluit
    v-list.mx-2
        v-btn(
            text="Laad preload (200MB)"
            @click="loadPreload()"
            :loading="test.loading.preload"
        )
        v-btn(
            text="Download Antwoordpagina"
            @click="downloadAnswerSheet()"
        )
        v-btn(
            text="Bekijk PWS"
            href="/pdf"
        )
        p Aantal modellen: {{ test.total_model_count }}
        v-select(
            :items='["google", "openai", "deepseek", "alibaba"]'
            v-model="test.gpt_provider"
            @update:modelValue="test.gpt_model = test.gpt_models(action)?.[0]?.value"
        )
        v-select(
            :items="test.gpt_models(action)"
            v-model="test.gpt_model"
            mandatory
        )
    slot
    v-divider
    div(v-if="hasSlot('drawer2')")
        slot(
            name="drawer2"
        )
</template>

<script>
import { getCurrentInstance } from 'vue';

export default {
    name: 'NavigationDrawer',
    props: {
        test: {
            type: Object,
            required: true
        },
        action: {
            type: String,
            required: false
        },
        selected_section_id: {
            type: String,
            required: false
        },
        is_loading: {
            type: Boolean,
            required: false
        }
    },
    setup(props, { slots }) {
        const hasSlot = name => !!slots[name]
        return { hasSlot }
    },
    data() {
      return {
        drawer: false,
      }
    },
    computed: {
        isDesktop() {
          return this.$vuetify.display.mdAndUp;
        },
    },
    methods: {
        async loadPreload() {
            await this.$parent.loadPreload()
        },
        async downloadAnswerSheet() {
            await this.$parent.downloadAnswerSheet()

        }
    }
};
</script>

# ======================
# File: src\components\full_view\RequestDialog.vue
# ======================


<template lang="pug">
v-dialog(max-width="700")
    template(v-slot:activator="{ props: activatorProps }")
        v-btn(v-bind="activatorProps") Requests ({{ active_requests.length }})
    template(v-slot:default="{ isActive }")
        v-card(title="Requests")
            v-btn(@click="active_requests.forEach((e,index) => {active_requests[index].abort()})") Abort all
            v-card-text
                v-table
                    thead
                        tr
                            th route
                            th params
                            th Model?
                            th(style="width: 100px") tijd
                            th abort
                    tbody
                        tr(v-for="(request, index) in active_requests")
                            td {{ request.route }}
                            td
                                v-btn(density="compact" @click="log(request.params)") params
                            td {{ request.params?.provider }} - {{ request.params?.model }}
                            td {{ request.prettyDuration() }} {{ rerender_timer ? '' : ''}}
                            td
                                v-icon(icon="mdi-close" @click="active_requests[index].abort()" color="red")
</template>

<script>
import { ref } from 'vue';
export default {
    name: 'RequestDialog',
    props: {
        active_requests: {
            type: Array,
            required: true,
        },
    },
    setup() {
        const rerender_timer = ref(true);
        setInterval(() => {
          rerender_timer.value = !rerender_timer.value;
        }, 100);
    return { rerender_timer };
  },
    methods: {
        log(data) {
            console.log(data)
        }
    }
};
</script>


# ======================
# File: src\components\full_view\SectionList.vue
# ======================


<template lang="pug">
v-list(
    :selected="[selected_section_id]"
    mandatory
)
    v-list-item Onderdelen
    v-divider
    v-list-item(
        v-for="section in main_sections"
        :key="section.id"
        :value="section.id"
        @click="$emit('update:selected_section_id', section.id)"
    ) {{ section.name }}
</template>

<script>
export default {
    name: 'SectionList',
    props: {
        main_sections: {
            type: Array,
            required: true,
        },
        selected_section_id: {
            type: String,
            required: true,
        },
    },
    emits: ['update:selected_section_id'],
};
</script>


# ======================
# File: src\components\full_view\SubsectionList.vue
# ======================


<template lang="pug">
v-list(
    :selected="[selected_subsection_id]"
    mandatory
)
    v-list-item(
        v-for="(section, index) in subsections"
        :key="section.id"
        :value="section.id"
        @click="$emit('update:selected_subsection_id', section.id)"
        nav
    ) {{ section.name }}
</template>

<script>
export default {
    name: 'SubsectionList',
    props: {
        subsections: {
            type: Array,
            required: true,
        },
        selected_subsection_id: {
            type: String,
            required: true,
        },
    },
    emits: ['update:selected_subsection_id'],
};
</script>


# ======================
# File: src\components\full_view\AnalyzeSection\AnalyzeSection.vue
# ======================


<template lang="pug">
div
    div(v-if="selected_subsection.id == 'individual'" style="position: relative")
        IndividualAnalysis(
            :test="test"
            :selected_student_id="selected_student_id"
            :selected_student="selected_student"
            :is_generating_pdf="is_generating_pdf"
            :self_feedback_field="self_feedback_field"
            @update:selected_student_id="$emit('update:selected_student_id', $event)"
            @update:is_generating_pdf="$emit('update:is_generating_pdf', $event)"
            @update:self_feedback_field="$emit('update:self_feedback_field', $event)"
            @download-student-results="$emit('download-student-results')"
            @download-selected-result="$emit('download-selected-result')"

        )
    div(v-if="selected_subsection.id == 'group'" style="position: relative")
        GroupAnalysis(:test="test")
</template>

<script>
import IndividualAnalysis from '@/components/full_view/AnalyzeSection/IndividualAnalysis.vue';
import GroupAnalysis from '@/components/full_view/AnalyzeSection/GroupAnalysis.vue';

export default {
    name: 'AnalyzeSection',
    components: {
        IndividualAnalysis,
        GroupAnalysis,
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            type: Object,
            required: true
        },
        selected_student_id: {
            type: String,
            required: true
        },
        is_generating_pdf: {
            type: Boolean,
            required: true,
        },
        self_feedback_field: {
            type: Boolean,
            required: true
        }
    },
    emits: ['update:selected_student_id', "update:is_generating_pdf", 'update:self_feedback_field', 'download-student-results', 'download-selected-result'],
    computed:{
        selected_student(){
            return this.test.students.find(student => student.id == this.selected_student_id)
        }
    },
    methods: {
        getGradeColor(percent){
            
            if (percent < 0.55){
                return 'rgba(255,100,100,'+(-percent + 0.55)+')'

            } 

            return 'rgba(100,255,100,'+(percent - 0.55)+')'
        },
    },
};
</script>


# ======================
# File: src\components\full_view\AnalyzeSection\GroupAnalysis.vue
# ======================


<template lang="pug">
div.pa-2(style="position: relative")
    h2 Per leerling
    v-table(density="compact")
        thead
            tr
                th Leerling
                th(v-for="question in test.questions") {{question.question_number}}
                th totaal
                th %
        tbody
            tr(v-for="student in test.students")
                td(style="height: fit-content") {{ student.student_id }}
                td(style="height: fit-content" v-for="question in test.questions") {{ student.question_results[question.id].received_points }} / {{ student.question_results[question.id].total_points }}
                td(style="height: fit-content") {{ student.received_points }} / {{ test.total_points }}
                td(style="height: fit-content" :style="{'background-color': getGradeColor(student.received_points / test.total_points)}") {{ (student.received_points / test.total_points * 100).toFixed(1) }}%
            tr
                th Totaal
                th(v-for="question in test.questions") {{ average(test.students.map(e => e.question_results[question.id].received_points)).toFixed(2) }}
                th {{ average(test.students.map(e => e.received_points / test.total_points * 100)).toFixed(1) }}

    h2 Per Leerdoel
    h2 Per leerdoel
    v-table(:theme=" is_generating_pdf ? 'light' : ''")
        thead
            tr
                th Leerdoel
                th Uitleg leedoel
                th Punten
                th Percentage
        tbody
            tr(v-for="target in test.targets")
                td {{ target.target_name }}
                td {{ target.explanation }}
                td {{ target.average_received_points }} / {{ target.total_points }}
                td(:style="{'background-color': getGradeColor(target.average_received_points / target.total_points)}") {{ target.percent }}
</template>

<script>
import { average } from '@/helpers'
export default {
    name: 'GroupAnalysis',
    props: {
        test: {
            type: Object,
            required: true,
        },
        is_generating_pdf: {  // Assuming you might want this here too
            type: Boolean,
            required: false,  // Probably not required at the group level
            default: false,
        },
    },
    setup(){
        return {
            average
        }
    },
    methods: {
        getGradeColor(percent) {
            return this.$parent.getGradeColor(percent)  // Reuse from parent
        },
    },
};
</script>


# ======================
# File: src\components\full_view\AnalyzeSection\IndividualAnalysis.vue
# ======================


<template lang="pug">
div.d-flex.flex-row.h-100()
    v-list(:selected="[selected_student_id]" mandatory style="width: 155px;")
        v-list-item Leerlingen
        v-btn(@click="$emit('download-student-results')" text="Download Alle")
        v-switch(v-model="self_feedback_field_local" label="Zelfreflectieveld")
        v-divider
        v-list-item(v-for="student in test.students" :value="student.id" @click="$emit('update:selected_student_id', student.id)") {{ student.student_id }}
    v-divider(vertical)
    div.pa-2(style="width: calc(100% - 155px); position: relative;" v-if="selected_student || is_generating_pdf_local")
        div.d-flex.flex-row
            v-btn(@click="$emit('download-selected-result')" text="Download Selected Leerling Resultaten")
        v-progress-linear(v-if="is_generating_pdf_local" indeterminate style="position: fixed; top: 0; left: 0; z-index: 5")

        div.individualStudentResult(v-for="student in test.students.filter(student => student?.id == selected_student?.id || is_generating_pdf_local)" :class="student?.id == selected_student?.id ? 'selectedStudentResult' : ''" :style="{ 'background-color': is_generating_pdf_local ? 'white' : '', 'color': is_generating_pdf_local ? 'black' : ''}")
            h1 Leerling: {{ student.student_id }}
            h2 Per vraag

            v-table(:theme=" is_generating_pdf_local ? 'light' : ''")
                thead
                    tr
                        th Vraag
                        th(style="width: 30%") Antwoord
                        th Score
                        th Feedback
                        th(style="width: 30%") Score Per Punt
                tbody
                    tr(v-for="(question, index) in test.questions")
                        td {{ question.question_number }}
                        td
                            v-img(:src="student.question_results[question.id].result.scan.base64Image")
                        td {{ student.question_results[question.id].received_points }} / {{ student.question_results[question.id].total_points }}
                        td {{ student.question_results[question.id].result.feedback }}
                        td
                            v-table(:theme=" is_generating_pdf_local ? 'light' : ''")

                                tbody
                                    tr(v-for="point_result in student.question_results[question.id].result.point_results")
                                        td {{ point_result.point.point_name }}
                                        td(style="width: 50px") {{ point_result.has_point ? point_result.point.point_weight : 0 }}
                                        td(style="width: 50%") {{ point_result.feedback.length > 0 ? point_result.feedback : 'Geen feedback' }}
            h2 Per leerdoel
            v-table(:theme=" is_generating_pdf_local ? 'light' : ''")
                thead
                    tr
                        th Leerdoel
                        th Uitleg leedoel
                        th Punten
                        th Percentage
                tbody
                    tr(v-for="target in test.targets")
                        td {{ target.target_name }}
                        td {{ target.explanation }}
                        td {{ student.target_results[target.id].received_points }} / {{ student.target_results[target.id].total_points }}
                        td {{ student.target_results[target.id].percent }}
</template>

<script>
export default {
    name: 'IndividualAnalysis',
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_student_id: {
            type: String,
            required: true
        },
        selected_student: { // Added to pass selected student
            type: Object,
            required: false // It might not always be selected
        },
        is_generating_pdf: {
            type: Boolean,
            required: true,
        },
        self_feedback_field: {
            type: Boolean,
            required: true
        }
    },
    emits: ['update:selected_student_id', "update:is_generating_pdf", 'update:self_feedback_field', 'download-student-results', 'download-selected-result'],
    computed: {
        is_generating_pdf_local: {
            get() {
                return this.is_generating_pdf
            },
            set(val) {
                this.$emit('update:is_generating_pdf', val)
            }
        },
        self_feedback_field_local: {
            get() {
                return this.self_feedback_field
            },
            set(val) {
                this.$emit('update:self_feedback_field', val)
            }
        }
    }
};
</script>


# ======================
# File: src\components\full_view\GradeSection\GradeSection.vue
# ======================


<template lang="pug">
//- div(v-if="selected_subsection.id == 'grade_students'" style="position: relative")
div
    GradeStudents(
        :test="test"
        v-model:selected_student_id="_selected_student_id"
        @update:selected_student_id="selected_student_id = $event"
    )
</template>

<script>
import GradeStudents from '@/components/full_view/GradeSection/GradeStudents.vue';

export default {
    name: 'GradeSection',
    components: {
        GradeStudents,
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            // type: Object,
            required: false
        },
        selected_student_id: {
            type: String,
            required: false
        },

    },
    emits: ['update:selected_student_id'],
    computed: {
        _selected_student_id: {
            get() {
                return this.selected_student_id
            },
            set(val) {
                this.$emit('update:selected_student_id', val)
            }
        }
    }
};
</script>


# ======================
# File: src\components\full_view\GradeSection\GradeStudents.vue
# ======================


<template lang="pug">
h2 Leerlingen laden
div.d-flex.flex-row
    v-btn(text="Kijk alle leerlingen na" @click="test.gradeStudents()" :loading="test.loading.grading")
div.d-flex.flex-row.w-100(style="height: calc(100dvh - 72px)")
    v-list(:selected="[selected_student_id]" mandatory style="min-width: 155px; overflow-y: scroll")
        v-list-item Leerlingen
        v-divider
        v-list-item(v-for="student in test.students" :value="student.id" @click="$emit('update:selected_student_id', student.id)")
            v-progress-linear(v-if="student.is_grading" indeterminate)
            p {{ student.student_id }}
    v-divider(vertical)
    div.pa-2(v-if="selected_student" style="position: relative; overflow-y: scroll; width: calc(100% - 155px)")
        h2 Leerling {{ selected_student.student_id}}
        v-btn(text="Kijk leerling na" @click="test.students[selected_student_index].grade()" :loading="selected_student.is_grading")
        v-progress-linear(v-if="selected_student.is_grading" indeterminate style="position: fixed; top: 0; left: 0; z-index: 5")

        v-expansion-panels()
            v-expansion-panel(v-for="(result, index) in selected_student.results" :title="'Vraag '+result.question.question_number")
                v-expansion-panel-text
                    v-btn(@click="test.students[selected_student_index].results[index].grade()" :loading="selected_student.results[index].is_grading") Kijk vraag na
                    br
                    b Vraag:
                    p {{ result.question.question_text }}

                    b Antwoord Leerling:
                    v-img(style="max-height: 700px; " :src="result.scan.base64Image")
                    p {{ selected_student.results[index].scan.text }}

                    b Rubric
                    v-table(density="compact")
                        thead
                            tr
                                th Pt.
                                th Punt
                                th Uitleg
                                th.pa-0(style="width: 55px") Behaald
                                th(style="width: 35%") Feedback
                        tbody
                            tr(v-for="(rubric_point, point_index) in result.question.points")
                                td {{ rubric_point.point_weight }}
                                td {{ rubric_point.point_name }}
                                td {{ rubric_point.point_text }}
                                td
                                    v-checkbox.mx-auto(v-model="selected_student.results[index].point_results[rubric_point.point_index].has_point" density="compact")

                                td.pa-0
                                    v-textarea(v-model="selected_student.results[index].point_results[rubric_point.point_index].feedback" auto-grow :rows="1" density="compact")
                    b Feedback Volledige vraag
                    v-textarea(v-model="selected_student.results[index].feedback" auto-grow :rows="2" density="compact")
</template>

<script>
export default {
    name: 'GradeStudents',
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_student_id: {
            type: String,
            required: false
        },
    },
    computed: {
        selected_student_index() {
            return this.test.students.findIndex(e => e.id == this.selected_student_id);
        },
        selected_student(){
            if (this.selected_student_index == -1){
                return null;
            } else {
                return this.test.students[this.selected_student_index];
            }
        }
    },
    emits: ['update:selected_student_id']
};
</script>


# ======================
# File: src\components\full_view\ScanSection\GenerateStudents.vue
# ======================


<template lang="pug">
h2 Leerlingen laden
div.d-flex.flex-row
    v-btn(text="Laad leerlingen" @click="test.loadStudents()" :loading="test.loading.students")

div.d-flex.flex-row(style="height: calc(100dvh - 72px)")
    v-list(:selected="[selected_student_id]" mandatory style="min-width: 155px; overflow-y: scroll")
        v-list-item Leerlingen
        v-divider
        v-list-item(v-for="student in test.students" :value="student.id" @click="$emit('update:selected_student_id', student.id)") {{ student.student_id }}
    v-divider(vertical)
    div.pa-2(v-if="selected_student")
        h2 Leerling {{ selected_student.student_id}}
        v-expansion-panels()
            v-expansion-panel(v-for="(result, index) in selected_student.results" :title="'Vraag '+result.question.question_number")
                v-expansion-panel-text
                    b {{ result.question.question_text }}
                    v-img(style="max-height: 700px; " :src="result.scan.base64Image")
                    v-textarea(label="antwoord leerling" v-model="selected_student.results[index].scan.text" auto-grow :rows="1")
                    v-btn(text="Scan text" @click="test.students[selected_student_index].results[index].scan.extractText(this.test.test_context, this.test.gpt_provider, this.test.gpt_model)" :loading="test.students[selected_student_index].results[index].scan.is_loading")
</template>

<script>
export default {
    name: 'GenerateStudents',
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_student_id: {
            type: String,
            required: true,
        },
        selected_student: {
            type: Object,
            required: false
        },
        selected_student_index: {
            type: Number,
            required: false
        }

    },
    emits: ['update:selected_student_id'],
};
</script>


# ======================
# File: src\components\full_view\ScanSection\LoadPages.vue
# ======================


<template lang="pug">
v-row(style="height: 100dvh")
    v-col
        h2 PDF {{ selected_subsection.name }}
        b 1 pdf tegelijk (inladen met knop), foto's laden automatisch
        div.d-flex.flex-row
            v-file-input(v-model="test.files.students.raw" accept="application/pdf  image/*" @update:modelValue="handleFileChange" multiple)
            v-btn(text="Laad toets" @click="test.loadDataFromPdf(selected_subsection.id)" :loading="test.loading.pdf_data")
        object.w-100(style="height: calc(100% - 40px)" :data="test.files.students.url" type="application/pdf" class="internal")
            embed(v-if="test.files.students.url" :src="test.files.students.url" type="application/pdf")
    v-col.h-100(style="overflow-y: scroll; position: relative")
        v-card.d-flex.flex-row(style="position: sticky; top: 0; z-index: 3")
            h2 Computerdata
        div.d-flex.flex-wrap
            div.pa-1(style="position: relative; width: 50%" v-for="(page, index) in test.pages")
                v-progress-linear(v-if="page.is_loading" indeterminate style="position: fixed; top: 0; left: 0; z-index: 5")
                div.d-flex.flex-row.flex-wrap
                    v-btn.mr-1(text="Crop" @click="test.pages[index].cropImage()")
                    v-btn.mr-1(text="Rode pen" @click="test.pages[index].colorCorrect()")

                    v-select(:items="page.image_options" v-model="test.pages[index].selected_image_type" density="compact")
                    v-icon.mr-1(icon="mdi-flip-vertical" @click="async () => {test.pages[index].image = await rotateImage180(test.pages[index].image)}")
                    v-icon.ml-auto(icon="mdi-delete" color="red" @click="test.files.students.data.splice(index,1)")

                img.w-100(:src="page.image")
</template>

<script>
import {
    rotateImage180
} from '@/helpers';
export default {
    name: 'LoadPages',
    props: {
        test: {
            type: Object,
            required: true
        },
        selected_subsection: { // Add this prop
            type: Object,
            required: true
        }
    },
    setup() {
        return {
            rotateImage180
        }
    },
    emits: ['load-student-pages'],
    methods: {
        handleFileChange(event) {
            this.$emit('load-student-pages', event) // Emit the event
        }
    }
};
</script>


# ======================
# File: src\components\full_view\ScanSection\ScanPages.vue
# ======================


<template lang="pug">
h2 Scan pages
div.d-flex.flex-row
    v-btn(text="Laad alle data" @click="test.scanStudentIdsAndSections()" :loading="test.loading.sections")

ImagesPreview(height="calc(100dvh - 80px)" :items="test.pages.map((page, index) => {return {page, index, id:page.id, image: page.base64Image, is_loading: page.is_loading_all, title:(index+1).toString()}})" @delete="test.pages.splice(test.pages.findIndex(e => e.id == $event), 1)" :hasDeleteButton="true" v-model="selected_page_id_local")
    template(v-slot:selected="{ item }")
        //- v-progress-linear(v-if="test.loading.sections" indeterminate style="position: fixed; top: 0; left: 0; z-index: 5")

        v-btn(text="laad deze pagina" @click="async () => {this.test.loading.sections = true; await test.pages[item.index].detectStudentId(); await test.pages[item.index].loadSections();this.test.loading.sections = false}")
        v-row.w-100
            v-col
                img(v-if="item.image" style="max-height: 100%; max-width: 100%" v-fullscreen-img="{scaleOnHover: true}" :src="item.image")
            v-col.w-50
                v-text-field(label="Leerlingnummer" v-model="test.pages[item.index].student_id")
                v-table
                    thead
                        tr
                            th Sectie
                            th Aangekruisde Vraag
                    tbody
                        tr(v-for="(section, section_index) in item.page.sections")
                            td {{ section_index + 1 }}
                            td
                                v-number-input(v-model="test.pages[item.index].sections[section_index].question_number" type="number" :min="0" controlVariant="stacked" density="compact" label="aangekruisde vraag")
</template>

<script>
import ImagesPreview from '@/components/image/ImagesPreview.vue';

export default {
    name: 'ScanPages',
    components: {
        ImagesPreview
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_page_id: {
            type: String,
            required: false
        }
    },
    emits: ['update:selected_page_id'],
    computed: {
        selected_page_id_local: {
            get() {
                return this.selected_page_id
            },
            set(val) {
                this.$emit('update:selected_page_id', val)
            }
        }
    }
};
</script>


# ======================
# File: src\components\full_view\ScanSection\ScanSection.vue
# ======================


<template lang="pug">
div
    div(v-if="selected_subsection.id == 'load_pages'")
        LoadPages(
            :test="test"
            :selected_subsection="selected_subsection"
            @load-student-pages="handleLoadStudentPages"
        )

    div(v-if="selected_subsection.id == 'scan_pages'")
        ScanPages(
            :test="test"
            v-model:selected_page_id="_selected_page_id"
            @update:selected_page_id="$emit('update:selected_page_id', $event)"

        )

    div(v-if="selected_subsection.id == 'generate_students'" style="position: relative")
        GenerateStudents(
            :test="test"
            v-model:selected_student_id="_selected_student_id"
            :selected_student="selected_student"
            :selected_student_index="selected_student_index"
            @update:selected_student_id="$emit('update:selected_student_id', $event)"
        )
</template>

<script>
import LoadPages from '@/components/full_view/ScanSection/LoadPages.vue';
import ScanPages from '@/components/full_view/ScanSection/ScanPages.vue';
import GenerateStudents from '@/components/full_view/ScanSection/GenerateStudents.vue';

export default {
    name: 'ScanSection',
    components: {
        LoadPages,
        ScanPages,
        GenerateStudents,
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            type: Object,
            required: true
        },
        selected_page_id: {
            type: String,
            required: false
        },
        selected_student_id: {
            type: String,
            required: false
        }
    },
    emits: ['update:selected_page_id', 'update:selected_student_id', 'load-student-pages'],
    methods: {
        handleLoadStudentPages(event) {
            this.$emit('load-student-pages', event) // Emit the event
        }
    },
    computed: {
        selected_student: {
            get() {
                return this.test.students.find(e => e.id == this.selected_student_id)
            },
            set(val) {
                const index = this.selected_student_index

                if (index != -1) {
                    this.test.students[index] = val
                }
            }
        },
        selected_student_index() {
            return this.test.students.findIndex(e => e.id == this.selected_student_id)
        },
        _selected_page_id: {
            get(){return this.selected_page_id},
            set(val){this.$emit('update:selected_page_id', val)}
        },
        _selected_student_id: {
            get(){return this.selected_student_id},
            set(val){this.$emit('update:selected_student_id', val)}
        },
    }
};
</script>


# ======================
# File: src\components\full_view\TestSection\DownloadTest.vue
# ======================


<template lang="pug">
v-card.ma-2.pa-2
    h3 Download toets
    v-text-field(v-model="test.test_settings.test_name" label="naam")
    v-checkbox(v-model="test.test_settings.show_targets" label="Toon leerdoelen")
    v-checkbox(v-model="test.test_settings.show_answers" label="Toon antwoorden")
    v-select(v-model="test.test_settings.output_type" :items="['pdf', 'docx']" label="Output")
    p(style="color: red" v-if="test.test_settings.output_type == 'docx'") !Pas op! vragen worden door page-breaks gebroken
    v-btn(@click="test.downloadTest()" :loading="test.loading.test_pdf") Download Toets Pdf
</template>

<script>
export default {
    name: 'DownloadTest',
    props: {
        test: {
            type: Object,
            required: true
        }
    }
}
</script>


# ======================
# File: src\components\full_view\TestSection\GenerateQuestion.vue
# ======================


<template lang="pug">
v-card.ma-2()
    v-card-text
        h3 Genereer nieuwe vraag
        v-radio-group(v-model="test.gpt_question.rtti" inline label="Vraag type")
            v-radio(value="Reproductie" label="Reproductie")
            v-radio(value="Training" label="Training")
            v-radio(value="Transfer" label="Transfer")
            v-radio(value="Inzicht" label="Inzicht")
            v-radio(value="Maakt niet uit" label="Maakt niet uit")
        v-text-field(label="Idee/onderwerp" v-model="test.gpt_question.subject")
        v-number-input(v-model="test.gpt_question.point_count" type="number" :min="0" controlVariant="stacked" density="compact" label="max aantal punten")
        div
            p.text-gray Leerdoel (niets selecteren = alle leerdoelen)
            v-checkbox(v-for="target in test.targets" :label="target.target_name" :modelValue="test.gpt_question.targets[target.id]" @update:modelValue="test.gpt_question.targets[target.id] = !test.gpt_question.targets[target.id]" density="compact")
        v-btn(@click="test.generateGptQuestion()") Genereer vraag
</template>

<script>
export default {
    name: 'GenerateQuestion',
    props: {
        test: {
            type: Object,
            required: true
        }
    }
}
</script>


# ======================
# File: src\components\full_view\TestSection\LearningTargets.vue
# ======================


<template lang="pug">
div
    h2.ml-4 Leerdoelen
    v-table.ma-2(density="compact" style="border-radius: 5px")
        thead
            tr
                th Naam
                th Uitleg
                th(width="55px")
        tbody
            tr(v-for="(target, index) in test.targets")
                td.pa-0
                    v-textarea(v-model="test.targets[index].target_name" density="compact" auto-grow :rows="1")
                td.pa-0
                    v-textarea(v-model="test.targets[index].explanation" auto-grow :rows="1" density="compact")
                td.pa-0
                    v-icon(icon="mdi-delete" color="red" @click="test.targets.splice(index,1)")
    v-btn.ml-4(prepend-icon="mdi-plus" text="Voeg toe" @click="test.addTarget({})")
</template>

<script>
export default {
    name: 'LearningTargets',
    props: {
        test: {
            type: Object,
            required: true,
        },
    },
};
</script>


# ======================
# File: src\components\full_view\TestSection\PdfDataDisplay.vue
# ======================


<template lang="pug">
div(v-for="(item,index) in  test.files[selected_subsection.id].data")
    v-expansion-panels
        v-expansion-panel
            v-expansion-panel-title {{ item.type }}
            v-expansion-panel-text
                div(v-if="item.type == 'text'")
                    v-textarea(v-model="test.files[selected_subsection.id].data[index].data")
                div(v-if="item.type == 'image'")
                    img(style="height: 300px" :src="item.data")
</template>

<script>
export default {
    name: 'PdfDataDisplay',
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            type: Object,
            required: true
        }
    },
};
</script>


# ======================
# File: src\components\full_view\TestSection\PdfLoader.vue
# ======================


<template lang="pug">
v-row.h-100()
    v-col( md="6" sm="12")
        h2 PDF {{ selected_subsection.name }}
        div.d-flex.flex-row
            v-file-input(
                v-model="test.files[selected_subsection.id].raw"
                accept="application/pdf"
                @update:modelValue="async ($event) => {test.files[selected_subsection.id].url = await toDataURL($event)}"
            )
            v-btn(
                text="Laad toets"
                @click="test.loadDataFromPdf(selected_subsection.id)"
                :loading="test.loading.pdf_data"
            )
        object.w-100(style="height: calc(100% )" :data="test.files[selected_subsection.id].url" type="application/pdf" class="internal")
            embed(
                v-if="test.files[selected_subsection.id].url"
                :src="test.files[selected_subsection.id].url"
                type="application/pdf"
            )
    v-col.h-100(style="overflow-y: scroll; position: relative" md="6" sm="12")
        v-card.d-flex.flex-row(style="position: sticky; top: 0; z-index: 3")
            h2 Computerdata
        PdfDataDisplay(:test="test" :selected_subsection="selected_subsection")
</template>

<script>
import PdfDataDisplay from '@/components/full_view/TestSection/PdfDataDisplay.vue';

export default {
    name: 'PdfLoader',
    components: {
        PdfDataDisplay
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            type: Object,
            required: true,
        },
    },
    methods: {
        async toDataURL(file) {
            return await this.$parent.$parent.toDataURL(file)
        }
    }
};
</script>


# ======================
# File: src\components\full_view\TestSection\QuestionEditor.vue
# ======================


<template lang="pug">
div.d-flex.flex-row
    div
        v-icon(icon="mdi-chevron-up" :disabled="index == 0" @click="moveQuestionUp")
        v-icon(icon="mdi-chevron-down" :disabled="index == test.questions.length - 1" @click="moveQuestionDown")
        v-icon(icon="mdi-delete" color="red" @click="deleteQuestion")
    h3 {{ question.question_number + '. ' }}
    v-textarea(v-model="question.question_context" label="Context" auto-grow :rows="1")
    v-textarea(v-model="question.question_text" label="Vraag text" auto-grow :rows="1")
    v-switch(v-model="question.is_draw_question" label="Tekenvraag")

RubricEditor(:question="question")
</template>

<script>
import RubricEditor from '@/components/full_view/TestSection/RubricEditor.vue';

export default {
    name: 'QuestionEditor',
    components: {
        RubricEditor,
    },
    props: {
        question: {
            type: Object,
            required: true,
        },
        index: {
            type: Number,
            required: true
        },
        test: {
            type: Object,
            required: true
        }
    },
    methods: {
        moveQuestionUp() {
            if (this.index > 0) {
                [this.test.questions[this.index], this.test.questions[this.index - 1]] = [this.test.questions[this.index - 1], this.test.questions[this.index]];
                this.test.setQuestionNumbers();
            }
        },
        moveQuestionDown() {
            if (this.index < this.test.questions.length - 1) {
                [this.test.questions[this.index], this.test.questions[this.index + 1]] = [this.test.questions[this.index + 1], this.test.questions[this.index]];
                this.test.setQuestionNumbers();
            }
        },
        deleteQuestion() {
            this.test.questions.splice(this.index, 1);
            this.test.setQuestionNumbers();

        },
    },
};
</script>


# ======================
# File: src\components\full_view\TestSection\QuestionsEditor.vue
# ======================


<template lang="pug">
div
    h2.ml-4 Vragen
    div
        transition-group
            v-card.ma-2(v-for="(question, index) in test.questions" :key="question.id")
                v-card-text
                    QuestionEditor(:question="question" :index="index" :test="test")
        v-btn.ml-4(prepend-icon="mdi-plus" text="Voeg eigen vraag toe" @click="test.addQuestion({})")
        v-divider.ma-4
        GenerateQuestion(:test="test")
</template>

<script>
import QuestionEditor from '@/components/full_view/TestSection/QuestionEditor.vue';
import GenerateQuestion from '@/components/full_view/TestSection/GenerateQuestion.vue';
export default {
    name: 'QuestionsEditor',
    components: {
        QuestionEditor,
        GenerateQuestion
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
    },
};
</script>


# ======================
# File: src\components\full_view\TestSection\RubricEditor.vue
# ======================


<template lang="pug">
b Rubric
v-table(density="compact")
    thead
        tr
            th(style="width: 80px") Pt.
            th(style="width: 150px") Kort
            th Lang
            th Leerdoel
            th(width="55px")
    tbody
        tr(v-for="(rubric_point, point_index) in question.points")
            td.pa-0
                v-number-input(v-model="question.points[point_index].point_weight" type="number" :min="0" controlVariant="stacked" density="compact")
            td.pa-0
                v-textarea(v-model="question.points[point_index].point_name" density="compact" multi-line auto-grow :rows="1")
            td.pa-0
                v-textarea(v-model="question.points[point_index].point_text" auto-grow :rows="1" density="compact")
            td.pa-0
                v-select(:items="test.targets.map((e,index) => {return {name: e.target_name, id: e.id}})" :modelValue="question.points[point_index].target_id" item-title="name" item-value="id" density="compact" @update:model-value="question.points[point_index].target_id = $event")
            td.pa-0
                v-icon(icon="mdi-delete" color="red" @click="question.points.splice(point_index,1)")
v-btn(prepend-icon="mdi-plus" text="Voeg punt toe" @click="question.addRubricPoint({})")
</template>

<script>
export default {
    name: 'RubricEditor',
    props: {
        question: {
            type: Object,
            required: true,
        },
    },
    computed: {
        test() {
            return this.question.test
        }
    }
};
</script>


# ======================
# File: src\components\full_view\TestSection\TestSection.vue
# ======================


<template lang="pug">
div.h-100()
    PdfLoader(
        v-if="selected_subsection.id == 'test' || selected_subsection.id == 'rubric'"
        :test="test"
        :selected_subsection="selected_subsection"
    )

    TestStructure(
        v-if="selected_subsection.id == 'structure'"
        :test="test"
        :selected_test_source="selected_test_source"
        @update:selected_test_source="$emit('update:selected_test_source', $event)"
    )
</template>

<script>
import PdfLoader from '@/components/full_view/TestSection/PdfLoader.vue';
import TestStructure from '@/components/full_view/TestSection/TestStructure.vue';

export default {
    name: 'TestSection',
    components: {
        PdfLoader,
        TestStructure,
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_subsection: {
            type: Object,
            required: true
        },
        selected_test_source: {
            type: String,
            required: true
        }
    },
    emits: ['update:selected_test_source'],
};
</script>


# ======================
# File: src\components\full_view\TestSection\TestStructure.vue
# ======================


<template lang="pug">
div
    //- v-progress-linear(v-if="test.loading.structure" indeterminate style="position: fixed; top: 0; left: 0; z-index: 5")
    v-card()
        v-tabs(v-model="selected_test_source_local")
            v-tab(value="gpt") AI
            v-tab(value="pdf") PDF's
        v-card-text
            v-tabs-window(v-model="selected_test_source_local")
                v-tabs-window-item.w-100(value="gpt")
                    v-radio-group(v-model="test.gpt_test.school_type" inline)
                        v-radio(value="basisschool" label="basisschool")
                        v-radio(value="vmbo" label="vmbo")
                        v-radio(value="havo" label="havo")
                        v-radio(value="vwo" label="vwo")
                        v-radio(value="mbo" label="mbo")
                        v-radio(value="hbo" label="hbo")
                        v-radio(value="universiteit" label="universiteit")

                    v-number-input(type="number" v-model="test.gpt_test.school_year")
                    v-combobox(label="Vak" v-model="test.gpt_test.school_subject"  :items="courses.map(e => e.subject)" )
                        template(#item="{ item, props }")
                            v-list-item(
                                @click="test.gpt_test.school_subject = item.title; selected_course ? test.grade_rules = selected_course.exam_grade_rules : {}"
                            ) {{item.title}}
                    v-expansion-panels(density="compact" elevation="0")
                        v-expansion-panel
                            v-expansion-panel-title Nakijkregels
                            v-expansion-panel-text
                                v-textarea(
                                    label="Nakijkregels"
                                    hint="Dit wordt aan het nakijkmodel meegegeven om het resultaat te verbeteren, schijf hier bijvoorbeeld concreet kleine nakijkregels zoals super en sub script bij O2"
                                    auto-grow
                                    v-model="test.grade_rules"
                                    :rows="2"
                                )
                                i.text-warning Let op! Het selecteren van een ander vak overschrijft deze waarde.
                    v-combobox(label="Onderwerp" v-model="test.gpt_test.subject" :items="subjects")
                    v-textarea(label="geleerde stof (optioneel)" auto-grow :rows="2" v-model="test.gpt_test.learned")
                    v-textarea(label="Onderwerpen die voor moeten komen" hint="Scheiden met komma's" auto-grow :rows="2" v-model="test.gpt_test.requested_topics")
                    v-btn.mt-2(@click="test.generateGptTest()") Genereer vragen

                v-tabs-window-item(value="pdf")
                    v-btn(text="Laad structuur met gpt request uit pdfs" @click="test.loadTestStructure()" :loading="test.loading.structure")

    LearningTargets(:test="test")
    QuestionsEditor(:test="test")
    DownloadTest(:test="test")
</template>

<script>
import LearningTargets from '@/components/full_view/TestSection/LearningTargets.vue';
import QuestionsEditor from '@/components/full_view/TestSection/QuestionsEditor.vue';
import GenerateQuestion from '@/components/full_view/TestSection/GenerateQuestion.vue';
import DownloadTest from '@/components/full_view/TestSection/DownloadTest.vue';

export default {
    name: 'TestStructure',
    components: {
        LearningTargets,
        QuestionsEditor,
        GenerateQuestion,
        DownloadTest
    },
    props: {
        test: {
            type: Object,
            required: true,
        },
        selected_test_source: {
            type: String,
            required: true
        }
    },
    emits: ['update:selected_test_source'],
    data() {
        return {
            courses: [
                {
                    "subject": "Natuurkunde",
                    "topics": [
                    "Mechanica",
                    "Elektriciteit en Magnetisme",
                    "Golven",
                    "Warmteleer",
                    "Moderne Natuurkunde"
                    ],
                    "exam_grade_rules": "De examinator beoordeelt het natuurkunde-examen op basis van de volgende regels:\n\n1. **Correctheid van Antwoorden:**\n   a. Elke vraag heeft een specifiek puntenaantal gebaseerd op de complexiteit en het aantal vereiste stappen.\n   b. Antwoorden worden beoordeeld op wetenschappelijke nauwkeurigheid, gebruik van correcte formules, en juiste eenheden.\n   c. Deelpunten worden toegekend voor correcte tussenstappen, zelfs als het eindantwoord onjuist is, mits de gebruikte methode en formules relevant zijn.\n   d. Bij numerieke antwoorden moet de significantie van cijfers in acht worden genomen.\n   e. Fouten in berekeningen (bijv. rekenfouten) leiden tot puntenaftrek, maar doorrekenfouten (fout voortzetten in volgende berekeningen) worden slechts Ã©Ã©n keer bestraft.\n\n2. **Begrip en Inzicht:**\n   a. Antwoorden moeten blijk geven van begrip van de onderliggende natuurkundige principes.\n   b. Toelichtingen en verklaringen moeten helder, logisch en consistent zijn met de natuurkundige wetten.\n   c. Bij open vragen wordt beoordeeld of de kandidaat de relevante concepten kan toepassen op nieuwe situaties.\n\n3. **Gebruik van Hulpmiddelen:**\n   a. Het gebruik van een goedgekeurde rekenmachine is toegestaan.\n   b. Het gebruik van een formuleblad (bijv. Binas) is toegestaan, maar de kandidaat moet de juiste formules correct selecteren en toepassen.\n   c. Ongestoornd gebruik van niet-toegestane hulpmiddelen (bijv. internet, communicatieapparatuur) leidt tot ongeldigverklaring van het examen.\n\n4. **Presentatie en Structuur:**\n    a. Antwoorden moeten leesbaar en gestructureerd zijn.\n    b. Duidelijke scheiding tussen verschillende onderdelen van een vraag is vereist.\n    c. Gebruik van correcte natuurkundige terminologie is vereist.\n\n5. **Specifieke Instructies:**\n   a. De examinator volgt alle specifieke instructies en beoordelingscriteria die in het correctievoorschrift van het examen zijn opgenomen.\n   b. Bij twijfel over de interpretatie van een antwoord of beoordelingscriterium, overlegt de examinator met een tweede corrector of gecommitteerde.\n\n6. **Afronding:**\n   a.  Het eindcijfer wordt berekend volgens de normeringstabel behorende bij het examen.\n   b.  Het eindcijfer wordt afgerond op Ã©Ã©n decimaal (volgens de standaard afrondingsregels).\n\n7. **Tweede Correctie:** Alle examens worden door een tweede corrector nagekeken. Bij een significant verschil in beoordeling tussen de eerste en tweede corrector, wordt overlegd om tot een definitief cijfer te komen. Indien geen overeenstemming wordt bereikt, beslist de gecommitteerde."
                },
                {
                    "subject": "Wiskunde",
                    "topics": [
                    "Algebra",
                    "Meetkunde",
                    "Analyse/Calculus",
                    "Statistiek en Kansrekening"
                    ],
                    "exam_grade_rules": "De examinator beoordeelt het wiskunde-examen op basis van de volgende regels:\n\n1. **Correcte Methoden:**\n    a. De gebruikte wiskundige methoden moeten correct en relevant zijn voor het probleem.\n    b. Deelpunten worden toegekend voor correcte stappen in de uitwerking, zelfs als het eindantwoord onjuist is.\n    c. Alternatieve, correcte oplossingsmethoden worden eveneens geaccepteerd en beoordeeld.\n\n2. **Nauwkeurigheid:**\n    a. Berekeningen moeten nauwkeurig worden uitgevoerd.\n    b. Antwoorden moeten, waar van toepassing, worden vereenvoudigd en in de juiste vorm worden gepresenteerd (bijv. breuken vereenvoudigen, exacte antwoorden versus decimale benaderingen).\n    c. Afrondingsfouten worden bestraft, tenzij anders vermeld in de opgave.\n\n3. **Notatie en Symbolen:**\n    a. Correcte wiskundige notatie en symbolen moeten worden gebruikt.\n    b. Variabelen moeten duidelijk worden gedefinieerd.\n    c. Onjuist of inconsistent gebruik van notatie leidt tot puntenaftrek.\n\n4. **Logische Redenering:**\n    a. De oplossing moet een logische en coherente redenering volgen.\n    b. Stappen in de redenering moeten duidelijk worden uitgelegd en gerechtvaardigd.\n    c. Bij bewijzen moeten alle stappen expliciet worden vermeld en gebaseerd zijn op bekende definities en stellingen.\n\n5. **Grafieken en Diagrammen:**\n    a. Grafieken en diagrammen moeten correct, duidelijk en volledig zijn.\n    b. Assen moeten worden benoemd en voorzien van de juiste schaalverdeling.\n    c. Belangrijke punten (bijv. snijpunten, extremen) moeten worden aangegeven.\n\n6. **Hulpmiddelen:**\n    a. Het gebruik van een (grafische) rekenmachine is toegestaan, tenzij anders vermeld.\n    b. De kandidaat moet aangeven wanneer en hoe de rekenmachine is gebruikt.\n    c. Het gebruik van niet-toegestane hulpmiddelen leidt tot ongeldigverklaring.\n\n7. **Specifieke Instructies:** De examinator volgt strikt het correctievoorschrift en de daarin opgenomen specifieke beoordelingscriteria.\n\n8. **Afronding en Tweede Correctie:**\n    a. Het eindcijfer wordt berekend volgens de normeringstabel en afgerond volgens de standaardregels.\n    b. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen wordt overlegd, en de gecommitteerde neemt de eindbeslissing."
                },
                    {
                    "subject": "Economie",
                    "topics": [
                    "Micro-economie",
                    "Macro-economie",
                    "Internationale Economie",
                    "Bedrijfseconomie"
                    ],
                    "exam_grade_rules": "De examinator beoordeelt het economie-examen op basis van de volgende regels:\n\n1. **Economische Begrippen:**\n    a. Correct gebruik van economische begrippen en terminologie.\n    b. Duidelijke definities van relevante concepten.\n    c. Aantonen van begrip van de relaties tussen economische variabelen.\n\n2. **Analyse en Toepassing:**\n    a. Correcte toepassing van economische modellen en theorieÃ«n.\n    b. Analyse van economische vraagstukken met behulp van relevante gegevens.\n    c. Logische redeneringen en onderbouwde conclusies.\n\n3. **Grafieken en Tabellen:**\n   a. Correcte interpretatie en gebruik van grafieken en tabellen.\n   b. Juiste labels en schaalverdeling bij grafieken.\n   c. Verklaring van veranderingen in grafieken en tabellen.\n\n4. **Actualiteit en Context:**\n    a. Waar relevant, relatie leggen met actuele economische ontwikkelingen.\n    b. Rekening houden met de context van het vraagstuk (bijv. land, sector).\n\n5. **Argumentatie en Onderbouwing:**\n   a. Heldere en gestructureerde argumentatie.\n    b. Gebruik van relevante economische argumenten ter onderbouwing van standpunten.\n    c. Afwegen van voor- en nadelen van verschillende economische beleidsopties.\n\n6. **Rekenkundige Vaardigheden:**\n    a. Correct uitvoeren van berekeningen (bijv. elasticiteiten, indexcijfers).\n    b. Juiste interpretatie van de uitkomsten van berekeningen.\n\n7. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift nauwkeurig, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen. Bij significante verschillen volgt overleg, en de gecommitteerde neemt de eindbeslissing. Het eindcijfer wordt berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                },
                    {
                    "subject": "Biologie",
                    "topics": [
                    "Celbiologie",
                    "Ecologie",
                    "Fysiologie van Mens en Dier",
                    "Evolutie",
                    "Planten"
                    ],
                    "exam_grade_rules": "De examinator beoordeelt het biologie-examen op basis van de volgende regels:\n\n1. **Feitelijke Kennis:**\n    a. Correcte weergave van biologische feiten, begrippen en processen.\n    b. Gebruik van correcte biologische terminologie.\n\n2. **Begrip en Inzicht:**\n    a. Aantonen van begrip van de samenhang tussen biologische processen en structuren.\n    b. Verklaren van biologische verschijnselen op basis van biologische principes.\n    c. Toepassen van biologische kennis op nieuwe situaties.\n\n3. **Experimenten en Onderzoek:**\n    a. Correct interpreteren van onderzoeksgegevens (tabellen, grafieken).\n    b. Formuleren van een correcte hypothese en conclusie.\n    c. Beschrijven van een correcte onderzoeksmethode.\n    d. Benoemen van variabelen (onafhankelijk, afhankelijk, controle).\n\n4. **Schema's en Tekeningen:**\n    a. Correcte en duidelijke schema's en tekeningen (indien gevraagd).\n    b. Juiste benoeming van onderdelen.\n\n5. **Specifieke Instructies en Tweede Correctie:**\n    a. De examinator volgt het correctievoorschrift nauwkeurig en past de specifieke beoordelingscriteria toe.\n    b. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het eindcijfer wordt bepaald volgens de normeringstabel en afgerond volgens de standaardregels."
                },
                {
                    "subject": "Scheikunde",
                    "topics": [
                    "Atoombouw en Periodiek Systeem",
                    "Chemische Reacties",
                    "Zuren en Basen",
                    "Organische Chemie",
                    "Anorganische Chemie"
                    ],
                    "exam_grade_rules": "De examinator beoordeelt het scheikunde-examen op basis van de volgende regels:\n\n1. **Chemische Kennis:**\n    a. Correcte weergave van chemische feiten, begrippen, formules en reactievergelijkingen.\n    b. Gebruik van correcte chemische nomenclatuur.\n\n2. **Rekenkundige Vaardigheden:**\n    a. Correct uitvoeren van stoichiometrische berekeningen.\n    b. Correct gebruik van eenheden en significante cijfers.\n    c. Correcte berekeningen met betrekking tot zuur-base evenwichten, pH, en concentraties.\n\n3. **Reactievergelijkingen:**\n    a. Correct opstellen en kloppend maken van reactievergelijkingen.\n    b. Aangeven van de aggregatietoestanden (s, l, g, aq).\n\n4. **Begrip en Inzicht:**\n   a. Aantonen van begrip van de onderliggende chemische principes.\n    b. Verklaren van chemische verschijnselen.\n    c. Toepassen van chemische kennis op nieuwe situaties.\n\n5. **Laboratoriumvaardigheden:**\n    a. Correct interpreteren van experimentele gegevens.\n    b. Beschrijven van een correcte experimentele opzet.\n    c. Benoemen van veiligheidsmaatregelen (indien relevant).\n\n6. **Organische Chemie:**\n   a. Correct tekenen van structuurformules.\n   b. Benoemen van organische verbindingen.\n   c. Beschrijven van reacties van organische verbindingen.\n\n7. **Specifieke Instructies en Tweede Correctie:**\n    a. Strikt volgen van het correctievoorschrift en de bijbehorende beoordelingscriteria.\n    b. Een tweede corrector beoordeelt onafhankelijk het examen. Bij significante verschillen volgt overleg en neemt de gecommitteerde de eindbeslissing. Het cijfer wordt berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                },
                {
                        "subject": "Natuur, Leven en Technologie",
                        "topics": [
                            "Modules over diverse interdisciplinaire onderwerpen"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het NLT-examen op basis van de volgende regels:\n\n1. **Integratie van Disciplines:**\n a. Aantonen van begrip van de samenhang tussen de verschillende natuurwetenschappelijke disciplines (natuurkunde, scheikunde, biologie, aardwetenschappen).\n b. Correct toepassen van kennis en vaardigheden uit de verschillende disciplines.\n\n2. **Onderzoeksvaardigheden:**\n a. Correct interpreteren van onderzoeksgegevens (tabellen, grafieken).\n b. Formuleren van een correcte hypothese en conclusie.\n c. Beschrijven van een correcte onderzoeksmethode.\n d. Benoemen van variabelen (onafhankelijk, afhankelijk, controle).\n e. Kritisch evalueren van de betrouwbaarheid en validiteit van een onderzoek.\n\n3. **Concept-Context Benadering:**\n a. Toepassen van natuurwetenschappelijke concepten op realistische contexten.\n b. Verklaren van verschijnselen in de context met behulp van de relevante concepten.\n\n4. **Communicatie:**\n    a. Heldere en gestructureerde uitleg van de onderzoeksresultaten en conclusies.\n    b. Gebruik van correcte wetenschappelijke terminologie.\n\n5. **Module-Specifieke Kennis:**\n    a. Correcte weergave van de specifieke kennis en vaardigheden die horen bij de getoetste module(s).\n    b. Toepassen van deze kennis en vaardigheden op de gestelde vragen.\n\n 6. **Specifieke Instructies, Afronding en Tweede Correctie:** De examinator volgt het correctievoorschrift van de specifieke module(s) nauwkeurig, met inbegrip van de beoordelingscriteria. Een tweede corrector kijkt het examen onafhankelijk na. Bij significante verschillen is er overleg, met de gecommitteerde als eindbeslisser. Het eindcijfer wordt berekend volgens de geldende normen en correct afgerond."
                    },
                    {
                        "subject": "Nederlands",
                        "topics": [
                            "Leesvaardigheid",
                            "Schrijfvaardigheid",
                            "Taalbeschouwing",
                            "Literatuur"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het Nederlands-examen op basis van de volgende regels:\n\n1. **Leesvaardigheid:**\n    a. Correct beantwoorden van vragen over de inhoud van teksten.\n    b. Aantonen van begrip van de hoofdgedachte en structuur van teksten.\n    c. Correct interpreteren van teksten (bedoeling van de schrijver, standpunten, argumenten).\n    d. Correct samenvatten van teksten.\n\n2. **Schrijfvaardigheid:**\n    a. Correct formuleren (helder, correct taalgebruik, passend bij het doel en publiek).\n    b. Duidelijke structuur en opbouw van de tekst.\n    c. Correcte spelling en interpunctie.\n    d. Logische en overtuigende argumentatie (indien van toepassing).\n    e. Aansluiten bij de eisen van de specifieke tekstsoort (bijv. betoog, beschouwing, brief).\n\n3. **Taalbeschouwing:**\n   a. Correct toepassen van grammaticale regels.\n    b. Correcte spelling van woorden.\n    c. Aantonen van kennis van woordenschat en uitdrukkingen.\n\n4. **Literatuur:**\n   a. Aantonen van kennis van literaire begrippen en perioden.\n   b. Correct interpreteren van literaire werken (thema's, motieven, symboliek, personages).\n c. Beschrijven van de relatie tussen vorm en inhoud van literaire werken.\n\n5. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift strikt, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij aanzienlijke verschillen overleggen zij, en de gecommitteerde neemt de definitieve beslissing. Het eindcijfer wordt berekend volgens de normeringstabel en afgerond zoals voorgeschreven."
                    },
                {
                "subject": "Engels",
                "topics": [
                "Reading Comprehension",
                "Writing",
                "Listening Comprehension",
                "Speaking",
                "Literature"
                ],
                "exam_grade_rules": "De examinator beoordeelt het Engels-examen op basis van de volgende regels:\n\n1. **Reading Comprehension:**\n a. Accurate answers to questions about the content of texts.\n b. Demonstrated understanding of the main ideas and structure of texts.\n c. Correct interpretation of texts (author's intention, viewpoints, arguments).\n\n2. **Writing:**\n a. Correct and clear formulation (appropriate language, style, and register).\n b. Clear structure and organization of the text.\n c. Correct grammar, spelling, and punctuation.\n d. Logical and convincing argumentation (if applicable).\n e. Adherence to the requirements of the specific text type.\n\n3. **Listening Comprehension:**\n   a. Correctly answering questions on spoken texts, dialogues and monologues.\n b. Showing understanding of key information, details, and speakers' intentions.\n\n4. **Speaking: (If assessed as part of the central exam - often it's school-based)**\n a. Clear and fluent delivery of language.\n b. Correct and comprehensible pronunciation, intonation and stress.\n c. Grammatically sound production of spoken text.\n d. Use of correct vocabulary related to topics.\n\n5. **Literature:**\n a. Demonstrating understanding of characters, setting, plot of relevant works.\n b. Using correct terminology to discuss literary devices and themes.\n c. Making reasonable interpretations based on evidence from the text.\n\n6. **Specifieke Instructies en Tweede Correctie:**\n De examinator volgt strikt het correctievoorschrift, inclusief specifieke beoordelingscriteria. Een tweede examinator beoordeelt onafhankelijk het examen. Bij significante verschillen, overleggen zij en de gecommitteerde maakt de uiteindelijke beslissing. Het eindcijfer is berekend volgens de normeringstabel en afgerond volgens de voorschriften."
                },
                {
                        "subject": "Frans",
                        "topics": [
                            "ComprÃ©hension Ã©crite",
                            "Production Ã©crite",
                            "ComprÃ©hension orale",
                            "Production orale",
                            "Grammaire et Vocabulaire"

                        ],
                        "exam_grade_rules": "De examinator beoordeelt het Frans-examen op basis van de volgende regels:\n\n1. **ComprÃ©hension Ã©crite:**\n    a. RÃ©ponses correctes aux questions sur le contenu des textes.\n    b. ComprÃ©hension des idÃ©es principales et de la structure des textes.\n    c. InterprÃ©tation correcte des textes (intention de l'auteur, points de vue, arguments).\n\n2. **Production Ã©crite:**\n   a. Formulation correcte et claire (langue appropriÃ©e, style, registre).\n   b. Structure et organisation claires du texte.\n    c. Grammaire, orthographe et ponctuation correctes.\n    d. Argumentation logique et convaincante (le cas Ã©chÃ©ant).\n    e. Respect des exigences du type de texte spÃ©cifique.\n\n3. **ComprÃ©hension Orale (Als dit onderdeel centraal examen is):**\n    a. Correct beantwoorden van vragen over gesproken teksten.\n    b. Tonen van begrip van sleutelinformatie, details en intenties van de spreker.\n\n4. **Production Orale (Als dit onderdeel centraal examen is):**\n a. Duidelijke en vloeiende taalproductie.\n b. Correcte en begrijpelijke uitspraak.\n c. Grammaticaal correct gesproken tekst.\n d. Gebruik van correcte woordenschat met betrekking tot onderwerpen.\n\n5. **Grammaire et Vocabulaire:**\n a. Application correcte des rÃ¨gles grammaticales.\n b. Orthographe correcte des mots.\n c. Connaissance du vocabulaire et des expressions.\n\n6. **Specifieke Instructies en Tweede Correctie:** De examinator volgt strikt het correctievoorschrift, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het eindcijfer is berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                    },
                    {
                        "subject": "Duits",
                        "topics": [
                            "Leseverstehen",
                            "Schreiben",
                            "HÃ¶rverstehen",
                            "Sprechen",
                            "Grammatik und Wortschatz"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het Duits-examen op basis van de volgende regels:\n\n1. **Leseverstehen:**\n a. Richtige Antworten auf Fragen zum Inhalt der Texte.\n b. VerstÃ¤ndnis der Hauptgedanken und der Struktur der Texte.\n c. Korrekte Interpretation der Texte (Absicht des Autors, Standpunkte, Argumente).\n\n2. **Schreiben:**\n a. Korrekte und klare Formulierung (angemessene Sprache, Stil, Register).\n b. Klare Struktur und Organisation des Textes.\n c. Korrekte Grammatik, Rechtschreibung und Zeichensetzung.\n d. Logische und Ã¼berzeugende Argumentation (falls zutreffend).\n e. Einhaltung der Anforderungen der jeweiligen Textsorte.\n\n3. **HÃ¶rverstehen:**\n    a. Richtige Beantwortung von Fragen zu den gehÃ¶rten Texten.\n    b. Verstehen von SchlÃ¼sselinformation, Details und Sprecherabsichten.\n\n4. **Sprechen (indien als Teil des Zentralexamens geprÃ¼ft):**\n    a. Klare und flieÃŸende Sprachproduktion.\n    b. Korrekte und verstÃ¤ndliche Aussprache.\n    c. Grammatikalisch korrektes Sprechen.\n    d. Angemessener Wortschatz.\n\n5. **Grammatik und Wortschatz:**\n a. Korrekte Anwendung grammatikalischer Regeln.\n b. Richtige Schreibweise von WÃ¶rtern.\n c. Kenntnis von Vokabeln und AusdrÃ¼cken.\n\n6. **Specifieke Instructies en Tweede Correctie:** De examinator volgt strikt het correctievoorschrift, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het cijfer is berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                    },
                    {
                        "subject": "Spaans",
                        "topics": [
                            "ComprensiÃ³n de lectura",
                            "ExpresiÃ³n escrita",
                            "ComprensiÃ³n auditiva",
                            "ExpresiÃ³n oral",
                            "GramÃ¡tica y vocabulario"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het Spaans-examen op basis van de volgende regels:\n\n1. **ComprensiÃ³n de lectura:**\n    a. Respuestas correctas a preguntas sobre el contenido de los textos.\n    b. ComprensiÃ³n de las ideas principales y la estructura de los textos.\n    c. InterpretaciÃ³n correcta de los textos (intenciÃ³n del autor, puntos de vista, argumentos).\n\n2. **ExpresiÃ³n escrita:**\n a. FormulaciÃ³n correcta y clara (lenguaje, estilo y registro apropiados).\n b. Estructura y organizaciÃ³n claras del texto.\n c. GramÃ¡tica, ortografÃ­a y puntuaciÃ³n correctas.\n d. ArgumentaciÃ³n lÃ³gica y convincente (si corresponde).\n e. Cumplimiento de los requisitos del tipo de texto especÃ­fico.\n\n3. **ComprensiÃ³n Auditiva (Si es un examen central):**\n    a. Beantwoorden van vragen over gesproken teksten.\n    b. Begrip tonen van de belangrijkste informatie, details, en intenties van de spreker.\n\n4. **ExpresiÃ³n Oral (Si es un examen central):**\n    a. Duidelijke en vloeiende taalproductie.\n    b. Correcte en verstaanbare uitspraak.\n    c. Grammaticaal correct gesproken tekst.\n    d. Correct gebruik van woordenschat met betrekking tot de onderwerpen.\n\n5.  **GramÃ¡tica y Vocabulario:**\n  a. AplicaciÃ³n correcta de reglas gramaticales.\n b. OrtografÃ­a correcta de palabras.\n c. Conocimiento de vocabulario y expresiones.\n\n6. **Specifieke Instructies en Tweede Correctie:** De examinator volgt strikt het correctievoorschrift, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het eindcijfer wordt berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                    },
                        {
                        "subject": "Latijn",
                        "topics": [
                            "Taalvaardigheid",
                            "Cultuur"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het Latijn-examen op basis van de volgende regels:\n\n1. **Taalvaardigheid:**\n    a. **Vertaling:**\n        i.  Accurate vertaling van Latijnse zinnen en teksten naar correct Nederlands.\n        ii. Begrip van de grammaticale structuren en woordbetekenissen in de context.\n        iii. Vloeiende en begrijpelijke Nederlandse weergave van de Latijnse tekst.\n    b. **Grammatica:**\n        i.  Correcte identificatie en analyse van grammaticale vormen (naamvallen, werkwoordstijden, etc.).\n        ii. Correcte toepassing van grammaticale regels bij het beantwoorden van vragen.\n    c. **Woordenschat:**\n        i.  Kennis van de betekenis van Latijnse woorden.\n        ii. Juiste keuze van Nederlandse equivalenten.\n\n2. **Cultuur:**\n   a. Correcte en relevante antwoorden op vragen over de Romeinse geschiedenis, mythologie, literatuur en maatschappij.\n    b. Aantonen van inzicht in de culturele context van de Latijnse teksten.\n    c. Verbanden kunnen leggen tussen de Latijnse cultuur en de moderne wereld (indien van toepassing).\n\n3. **Specifieke Instructies en Tweede Correctie:** De examinator volgt strikt het correctievoorschrift en de daarin opgenomen specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen wordt overlegd; de gecommitteerde beslist uiteindelijk. Het eindcijfer wordt berekend volgens de normeringstabel en correct afgerond."
                    },
                    {
                        "subject": "Grieks",
                        "topics": [
                            "Taalvaardigheid",
                            "Cultuur"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het examen Grieks op basis van de volgende regels:\n\n1. **Taalvaardigheid:**\n a. **Vertaling:**\n i. Accurate vertaling van Griekse zinnen en teksten naar correct Nederlands.\n ii. Begrip van de grammaticale structuren en woordbetekenissen in context.\n iii. Vloeiende en begrijpelijke Nederlandse weergave van de Griekse tekst.\n b. **Grammatica:**\n i. Correcte identificatie en analyse van grammaticale vormen.\n ii. Correcte toepassing van grammaticale regels.\n c. **Woordenschat:**\n i. Kennis van de betekenis van Griekse woorden.\n ii. Juiste keuze van Nederlandse equivalenten.\n\n2. **Cultuur:**\n a. Correcte en relevante antwoorden op vragen over de Griekse geschiedenis, mythologie, literatuur, filosofie en maatschappij.\n b. Aantonen van inzicht in de culturele context van de Griekse teksten.\n c. Verbanden kunnen leggen tussen de Griekse cultuur en de moderne wereld (indien van toepassing).\n\n3. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift strikt, met inbegrip van alle specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante meningsverschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het eindcijfer wordt berekend aan de hand van de normeringstabel en correct afgerond."
                    },
                    {
                        "subject": "Geschiedenis",
                        "topics": [
                            "Tijdvakken",
                            "Thema's",
                            "Vaardigheden"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het geschiedenis-examen op basis van de volgende regels:\n\n1. **Feitelijke Kennis:**\n a. Correcte weergave van historische feiten, gebeurtenissen, personen en begrippen.\n b. Plaatsen van gebeurtenissen in de juiste tijdvakken en thema's.\n\n2. **Historisch Redeneren:**\n    a. Oorzaak-en-gevolg relaties kunnen uitleggen.\n    b. Veranderingen en continuÃ¯teit kunnen identificeren en verklaren.\n    c. Standpunten en meningen van historische personen kunnen herkennen en verklaren.\n    d. Vergelijkingen kunnen maken tussen historische perioden en gebeurtenissen.\n\n3. **Bronnenonderzoek:**\n a. Informatie uit historische bronnen (teksten, afbeeldingen, kaarten) kunnen halen.\n b. De bruikbaarheid, betrouwbaarheid en representativiteit van bronnen kunnen beoordelen.\n c. Bronnen kunnen gebruiken om een historisch argument te onderbouwen.\n\n4.  **Begrip en Inzicht**:\n a. Historische context plaatsen bij gebeurtenissen en personen.\n b. Uitleggen hoe ontwikkelingen invloed op elkaar hebben gehad.\n\n5. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift nauwkeurig, inclusief de specifieke beoordelingscriteria. Het examen wordt onafhankelijk nagekeken door een tweede corrector. Bij significante verschillen in beoordeling wordt overlegd; de gecommitteerde beslist uiteindelijk. Het eindcijfer wordt berekend volgens de normeringstabel en afgerond zoals voorgeschreven."
                    },
                    {
                        "subject": "Aardrijkskunde",
                        "topics": [
                            "Fysische Geografie",
                            "Sociale Geografie",
                            "Economische Geografie",
                            "Milieuvraagstukken"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het aardrijkskunde-examen op basis van de volgende regels:\n\n1. **Feitelijke Kennis:**\n    a. Correcte weergave van aardrijkskundige feiten, begrippen en processen.\n    b. Gebruik van correcte aardrijkskundige terminologie.\n\n2. **Geografisch Inzicht:**\n a. Aantonen van begrip van de relaties tussen verschijnselen in de fysische en sociale omgeving.\n    b. Verklaren van ruimtelijke spreidingspatronen en processen.\n    c. Toepassen van aardrijkskundige kennis op concrete situaties en gebieden.\n\n3. **Kaartvaardigheden:**\n   a. Correct interpreteren van kaarten (verschillende soorten, legenda, schaal).\n    b. Informatie uit kaarten halen en combineren.\n c.  Locaties en gebieden op kaarten identificeren.\n\n4. **Geografische Informatiesystemen (GIS):** (indien van toepassing in het curriculum/examen)\n a. Begrip van de basisprincipes van GIS.\n    b. Interpreteren van GIS-data en kaarten.\n\n5. **Onderzoeksvaardigheden:**\n    a. Interpreteren van geografische data (tabellen, grafieken, diagrammen).\n    b. Formuleren van een geografische onderzoeksvraag.\n    c. Trekken van conclusies op basis van geografische gegevens.\n\n6. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift strikt, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het cijfer wordt berekend volgens de normeringstabel en afgerond volgens de standaardregels."
                    },
                    {
                        "subject": "Maatschappijleer",
                        "topics": [
                            "Rechtsstaat",
                            "Parlementaire Democratie",
                            "Verzorgingsstaat",
                            "Pluriforme Samenleving",
                            "Internationale Betrekkingen"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het maatschappijleer-examen op basis van de volgende regels:\n\n1. **Feitelijke Kennis:**\n    a. Correcte weergave van begrippen, feiten en processen met betrekking tot de rechtsstaat, democratie, verzorgingsstaat, pluriforme samenleving en internationale betrekkingen.\n    b. Gebruik van correcte maatschappijleer-terminologie.\n\n2. **Begrip en Inzicht:**\n    a. Aantonen van begrip van de samenhang tussen de verschillende onderdelen van de maatschappij.\n    b. Verklaren van maatschappelijke vraagstukken en ontwikkelingen.\n    c. Toepassen van maatschappijleer-kennis op actuele situaties.\n\n3. **Waarden en Normen:**\n    a. Herkennen en analyseren van verschillende waarden en normen in de samenleving.\n    b. Beargumenteren van standpunten over maatschappelijke kwesties.\n    c. Reflecteren op de eigen waarden en normen in relatie tot maatschappelijke vraagstukken.\n\n4. **Brongebruik:**\n   a. Informatie halen uit verschillende soorten bronnen (teksten, grafieken, tabellen).\n   b. De betrouwbaarheid en representativiteit van bronnen beoordelen.\n\n5. **Specifieke Instructies en Tweede Correctie:** De examinator volgt strikt het correctievoorschrift, met inbegrip van de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen volgt overleg, waarbij de gecommitteerde de eindbeslissing neemt. Het eindcijfer wordt bepaald aan de hand van de normeringstabel en correct afgerond."
                    },
                    {
                        "subject": "Informatica",
                        "topics": [
                            "Programmeren",
                            "Computersystemen",
                            "Databases",
                            "Webtechnologie",
                            "Algoritmiek en Datastructuren"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het informatica-examen op basis van de volgende regels:\n\n1. **Programmeer Concepten:**\n   a. Aantonen van begrip van basisconcepten van programmeren (variabelen, datatypen, lussen, condities, functies).\n    b. Correct toepassen van deze concepten bij het schrijven van code.\n    c. Schrijven van leesbare, gestructureerde en efficiÃ«nte code.\n\n2. **Algoritmen en Datastructuren:**\n    a. Aantonen van begrip van algoritmen en datastructuren (bijv. sorteren, zoeken, lijsten, bomen, graphs).\n    b. Kunnen analyseren van de efficiÃ«ntie van algoritmen (tijdscomplexiteit, ruimtecomplexiteit).\n    c. Correct implementeren van algoritmen en datastructuren.\n\n3. **Probleemoplossend Vermogen:**\n   a. Vertalen van een probleemomschrijving naar een werkend computerprogramma.\n    b. Systematisch testen en debuggen van code.\n c.  Vinden van creatieve oplossingen voor computationele problemen.\n\n4. **Computersystemen:**\n   a. Kennis van de basiscomponenten van computersystemen (hardware, software).\n   b. Begrip van de werking van besturingssystemen en netwerken.\n\n5. **Databases (Indien Getoetst):**\n a. Kunnen ontwerpen van een eenvoudige database (entiteiten, attributen, relaties).\n b. Schrijven van SQL-queries om data op te vragen, toe te voegen, te wijzigen en te verwijderen.\n\n6. **Webtechnologie (Indien Getoetst):**\n a.  Maken van eenvoudige webpagina's met HTML, CSS en JavaScript.\n b. Begrijpen hoe client-server interactie werkt.\n\n7. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift nauwgezet, inclusief de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij aanzienlijke verschillen wordt overlegd, en de gecommitteerde beslist uiteindelijk. Het eindcijfer wordt vastgesteld volgens de normeringstabel en correct afgerond."
                    },
                    {
                        "subject": "Filosofie",
                        "topics": [
                            "Ethiek",
                            "Kennistheorie",
                            "Metafysica",
                            "Logica",
                            "Sociale en Politieke Filosofie"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het filosofie-examen op basis van de volgende regels:\n\n1. **Begrip van Filosofische Concepten:**\n    a. Correcte definities en uitleg van filosofische begrippen en theorieÃ«n.\n    b. Aantonen van inzicht in de relaties tussen verschillende filosofische concepten.\n\n2. **Argumentatie en Redenering:**\n   a. Heldere en gestructureerde argumentatie.\n    b. Gebruik van relevante filosofische argumenten ter onderbouwing van standpunten.\n    c. Kritische analyse van argumenten van anderen.\n    d. Identificatie van drogredenen en zwakke punten in redeneringen.\n\n3. **Analyse en Interpretatie:**\n    a. Correcte interpretatie van filosofische teksten.\n    b. Analyse van filosofische problemen en vraagstukken.\n c.  Verbanden leggen tussen filosofische ideeÃ«n en concrete situaties.\n\n4. **Zelfstandig Denken:**\n a. Ontwikkelen van een eigen beargumenteerd standpunt.\n    b. Kritisch reflecteren op eigen aannames en overtuigingen.\n c.  Formuleren van originele vragen en ideeÃ«n.\n\n5. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift nauwkeurig, met inbegrip van de specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen wordt overlegd; de gecommitteerde neemt de uiteindelijke beslissing. Het eindcijfer wordt berekend conform de normeringstabel en afgerond volgens de voorschriften."
                    },
                    {
                        "subject": "Onderzoek & Ontwerpen",
                        "topics": [
                            "Onderzoekscyclus",
                            "Ontwerpproces",
                            "Projectmanagement",
                            "Vakspecifieke kennis en vaardigheden"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het O&O-examen (vaak een combinatie van proces en product) op basis van de volgende regels:\n\n1. **Onderzoek:**\n    a. **Probleemstelling:** Duidelijke, relevante en onderzoekbare probleemstelling.\n    b. **Hypothese:** Toetsbare hypothese(s) gerelateerd aan de probleemstelling.\n    c. **Methode:** Geschikte onderzoeksmethode(n) gekozen en correct uitgevoerd.\n    d. **Data:** Relevante data verzameld en correct verwerkt.\n    e. **Analyse:** Correcte analyse van de data, leidend tot onderbouwde conclusies.\n    f. **Conclusie:** Duidelijke conclusie(s) gerelateerd aan de hypothese(s) en probleemstelling.\n    g. **Reflectie/Evaluatie:** Kritische reflectie op het onderzoeksproces en de resultaten.\n\n2. **Ontwerpen:**\n   a. **Probleemanalyse:** Grondige analyse van het ontwerpprobleem.\n    b. **Eisen en Wensen:** Duidelijk geformuleerde eisen en wensen.\n    c. **Ontwerp:** Functioneel en innovatief ontwerp dat voldoet aan de eisen en wensen.\n    d. **Prototype:** Werkend prototype (of gedetailleerde beschrijving/simulatie).\n    e. **Testen:** Systematisch testen van het prototype.\n    f. **Evaluatie:** Kritische evaluatie van het ontwerp en het prototype.\n\n3. **Projectmanagement:**\n a. **Planning:** Realistische planning en taakverdeling.\n    b. **Samenwerking:** Effectieve samenwerking (indien van toepassing).\n    c. **Communicatie:** Duidelijke communicatie over het project (tussentijds en eindverslag).\n   d. **Presentatie:** Professionele presentatie van het project (proces en product).\n\n4. **Vakoverstijgende Vaardigheden:** Creativiteit, doorzettingsvermogen, probleemoplossend vermogen, kritisch denken.\n\n5. **Rapportage**: Correcte weergave in verslaglegging, volgens de geldende eisen.\n\n6. **Specifieke Instructies en Beoordelingsteam:** De examinator(en) volgen de specifieke beoordelingscriteria van de school en/of het examenreglement nauwkeurig. Vaak is er een beoordelingsteam (meerdere docenten, eventueel externen). Bij verschil van mening wordt overlegd om tot een gezamenlijk oordeel te komen. Het eindcijfer is gebaseerd op zowel het proces als het product."
                    },
                    {
                        "subject": "Bedrijfseconomie",
                        "topics": [
                            "Marketing",
                            "Financiering",
                            "Management en Organisatie",
                            "Externe Verslaggeving",
                            "Interne Verslaggeving"
                        ],
                        "exam_grade_rules": "De examinator beoordeelt het bedrijfseconomie-examen op basis van de volgende regels:\n\n1. **Feitelijke Kennis:**\n    a. Correcte definities en uitleg van bedrijfseconomische begrippen en concepten.\n    b. Aantonen van kennis van relevante wet- en regelgeving (indien van toepassing).\n\n2. **Toepassing:**\n    a. Correct toepassen van bedrijfseconomische principes en methoden op concrete cases en situaties.\n    b. Analyseren van bedrijfseconomische vraagstukken en problemen.\n    c. Formuleren van oplossingen en aanbevelingen.\n\n3. **Rekenkundige Vaardigheden:**\n    a. Correct uitvoeren van berekeningen (bijv. ratio's, kengetallen, kostprijsberekeningen, investeringsanalyses).\n    b. Interpreteren van de uitkomsten van berekeningen.\n\n4. **Externe Verslaggeving:**\n    a. Begrip van de opbouw en inhoud van de balans, resultatenrekening en het kasstroomoverzicht.\n   b. Analyseren van financiÃ«le overzichten.\n\n5. **Interne Verslaggeving:**\n    a. Begrip van kostensoorten en kostprijsberekeningen.\n    b. Toepassen van budgetteringsmethoden.\n\n6. **Argumentatie:**\n   a.  Onderbouwen van standpunten met relevante bedrijfseconomische argumenten.\n  b.  Afwegen van voor- en nadelen van verschillende opties.\n\n7. **Specifieke Instructies en Tweede Correctie:** De examinator volgt het correctievoorschrift nauwgezet, met inbegrip van alle specifieke beoordelingscriteria. Een tweede corrector beoordeelt het examen onafhankelijk. Bij significante verschillen is er overleg; de gecommitteerde beslist. Het eindcijfer wordt berekend volgens de normeringstabel en correct afgerond."
                    }
            ]
        }
    },
    computed: {
        selected_test_source_local: {
            get() {
                return this.selected_test_source
            },
            set(val) {
                this.$emit('update:selected_test_source', val)
            }
        },
        selected_course(){
            return this.courses.find(course => course.subject == this.test.gpt_test.school_subject)
        },
        subjects(){
            if (!this.selected_course) return []
            return this.selected_course.topics
            
        }
    }
};
</script>


# ======================
# File: src\components\image\ImagesPreview.vue
# ======================

<template lang="pug">
v-card.pa-2.w-100.d-flex(
    color="#424242"
    :style="{'height': height}"
)
    p {{  $vuetify.mdAndUp}}
    div(:style="{'max-height': '100%', 'max-width': '130px', 'overflow-y': 'scroll'}" )
        div.w-100.d-flex.flex-column
            div.list-image.my-2(
                v-for="(item, index) in items"
                @click="selected_image_id=item.id"
                :class="{'selected-list-image': item.id==selected_image_id}"
                style="position: relative"

                
            )
                RequestLoader(
                    v-if="item.is_loading"
                )
                v-img(
                    :src="item.image"
                    style="min-width: 120px; min-height: 120px"
                )
                p.text-center {{ item.title }}
                v-divider(:vertical="!this.$vuetify.display.mdAndUp" color="white")
                div(v-if="hasDeleteButton" style="position: absolute; top: 0px; left: 0px")
                    v-icon(color="red" icon="mdi-delete" @click="$emit('delete', item.id)") 
    v-divider.px-1(vertical color="white")
    div.h-100(style="width: calc(100% - 126px); overflow-y: scroll; position: relative")
        slot(
            v-if="selected_item"
            name="selected" 
            :item="selected_item"
        )
    //- div(style="width: calc(100% - 126px); max-height: 100%")
        div(v-if="!isBeforeAfter")
            img(
                v-if="items[selected_image_id]"
                style="height: 100%"
                v-fullscreen-img="{scaleOnHover: true}"
                :src="items[selected_image_id]" 
            )
        div.d-flex.flex-row(v-else-if="items[selected_image_id] && items[selected_image_id].length == 2")
            div(v-for="(image, index) in items[selected_image_id]")
                div(:style="{'width': 'calc((100% - (2px * '+items[selected_image_id].length+')) / '+items[selected_image_id].length+')'}")
                    p {{ titles[index] }}
                    div(v-if="(items[selected_image_id]?.[index]?.constructor === Array)")
                        img(
                            v-for="sub_image in items[selected_image_id][index]"
                            v-if="sub_image"
                            style="height: auto; max-width: 100%"
                            v-fullscreen-img="{scaleOnHover: true}"
                            :src="sub_image" 
                        )
                    div(v-else)
                        img(
                            v-if="items[selected_image_id][index]"
                            style="height: auto; max-width: 100%"
                            v-fullscreen-img="{scaleOnHover: true}"
                            :src="items[selected_image_id][index]" 
                        )
                    v-divider.mx-1(vertical)
            
</template>

<script>
// Data 


// Components
import RequestLoader from '@/components/sub/RequestLoader'

export default {
    name: 'ImagesPreview',
    components: {
        RequestLoader
    },
    props: {
        modelValue: {
            required: false,
            default: null
        },
        items: {
            default: [],
        },
        titles: {
            default: ['current', 'after', '']
        },
        height: {
            default: '100%',
        },
        hasDeleteButton: {
            default: false
        },
        isBeforeAfter: {
            default: false
        }
    },
    emits: ['update:modelValue','delete'],
    setup() {
        
    },
    data(){
        return {
            local_model_value: 0
        }
    },
    computed: {

        selected_image_id: {
            get(){return this.modelValue || this.local_model_value},
            set(val){
                // if (this.modelValue){
                this.$emit('update:modelValue', val)
                // } 
                this.local_model_value = val
            }
        },
        selected_item() {
            return this.items.find(e => e.id == this.selected_image_id)
        }
    },
    methods: {
    
    },
    watch: {
    
    },
    // created() {
    
    // },
    mounted() {
        
    },
    
    
}
</script>
    
<style scoped>
.list-image{
    aspect-ratio: 1/1;
    width: 100%;
    /* height: 120px; */
    border: solid rgba(0, 0, 0, 0) 2px;
    position: relative;
    

}
.selected-list-image{
    border: solid black 2px
}
</style>


# ======================
# File: src\components\sub\RequestLoader.vue
# ======================

<template lang="pug">
v-overlay.d-flex.align-center.justify-center.flex-column(
    :modelValue="true"
    persistent
    contained
)
    div.d-flex.align-center.justify-center.flex-column
        v-progress-circular(indeterminate size="60")
        h2 {{ current_request_status}}

</template>

<script>
// Data 

// Components


export default {
   name: 'RequestLoader',
   components: {
   
   },
   props: {
    current_request_status: {
        type: String,
        default: ""
    }
   },
   emits: [],
   setup() {    

   },
   data(){
   return {
   
   }
   },
   computed: {
   
   },
   methods: {
   
   },
   watch: {
   
   },
   // created() {
   
   // },
   mounted() {
   },
   
   
}
</script>
   
<style scoped>

</style>


# ======================
# File: src\plugins\index.js
# ======================

/**
 * plugins/index.js
 *
 * Automatically included in `./src/main.js`
 */

// Plugins
import vuetify from './vuetify'

export function registerPlugins (app) {
  app.use(vuetify)
}


# ======================
# File: src\plugins\README.md
# ======================

# Plugins

Plugins are a way to extend the functionality of your Vue application. Use this folder for registering plugins that you want to use globally.


# ======================
# File: src\plugins\vuetify.js
# ======================

/**
 * plugins/vuetify.js
 *
 * Framework documentation: https://vuetifyjs.com`
 */

// Styles
import '@mdi/font/css/materialdesignicons.css'
import 'vuetify/styles'

// Composables
import { createVuetify } from 'vuetify'
import * as components from 'vuetify/components'
import * as labsComponents from 'vuetify/labs/components'

// https://vuetifyjs.com/en/introduction/why-vuetify/#feature-guides
export default createVuetify({
  components: {
    ...components,
    ...labsComponents,
  },
  theme: {
    defaultTheme: 'dark',
    printTheme: false
  },
  defaults: {
    global: {
        // elevation: 0,
        hideDetails: 'auto'

    },
    VTextField: {
        hideDetails: 'auto'
    },
    // make sure swiping is disabled: this can cause users to access windows wich are not ment for them
    VWindow: {
        touch: {left: ()=>{}, right:()=>{}}
    },
    VInput: {
        hideDetails: 'auto'
    },
    VSwitch: {
        color: 'primary'
    },
    VBtn: {
        color: 'primary'
    
    }

  }
})


# ======================
# File: src\router\index.js
# ======================

// CONFIG & FUNCTIONS
import { createRouter, createWebHistory } from 'vue-router'

import AnalisisView from '@/views/AnalisisView'
import ScanView from '@/views/ScanView'
import FullView from '@/views/FullView.vue'
import HomeView from '@/views/HomeView.vue'
import PdfView from '@/views/PdfView.vue'

const routes = [
    {
        path: '/scan',
        name: 'scan',
        component: ScanView
    },
    {
        path: '/analyze',
        name: 'analisis',
        component: AnalisisView
    },

    {
      path: '/pdf',
      name: 'pdf',
      component: PdfView,
      props: true
    },
    {
        path: '/',
        name: 'full',
        component: FullView
    },
    {
        path: '/home',
        name: 'home',
        component: HomeView
    },
    {
        path: '/:pathMatch(.*)*',
        name: 'not-found',
        redirect: '/'
    }
]
const scrollBehavior = (to, from, savedPosition) => {
    return savedPosition ||
        to.meta?.scrollPos ||
        { top: 0, left: 0 }
}
// history: createWebHistory(process.env.BASE_URL),
const router = createRouter({
  history: createWebHistory(),
  routes: routes,
  navigationFallback: {
    rewrite: "/index.html",
    exclude: ["/images/*.{png,jpg,gif}", "/css/*"]
  },
  scrollBehavior
})

export default router

# ======================
# File: src\stores\data_store.js
# ======================

import { defineStore } from 'pinia'
import { data_classes } from '@/data_classes';

export const useDataStore = defineStore("ContentStore", {
    // state
    state: () => {
        return {

        }
    },
    // actions
    actions: {

    },
})

export { useDataStore }

# ======================
# File: src\views\AnalisisView.vue
# ======================

<template lang="pug">
div

    v-select(
        :items="tests.map(e=>{return {title: e.name, value: e.id}})"
        v-model="selected_test_id"
    )

    v-tabs(v-model='selected_tab')
        v-tab(value="load") Laad
        v-tab(value="analyse" v-if="is_loaded") Analyseer
        v-tab(value="edit" v-if="is_loaded") Bewerk
    v-window(v-model='selected_tab' style="height: calc(100dvh - 48px); position: relative")
        v-window-item(value="load") 
            v-row(style="max-height: calc(100dvh - 60px)")
                v-col.v-col-12.v-col-sm-4
                    v-expansion-panels
                        v-expansion-panel
                            v-expansion-panel-title Uitleg
                            v-expansion-panel-text
                                div
                                    h3 Stappenplan
                                    p Stap 1: zorg ervoor dat uw excel bestand er als volgt uit ziet 
                                    img.w-100(
                                        v-fullscreen-img="{scaleOnHover: true}"
                                        src="@/assets/excel_example.png"
                                    )
                                    p Stap 2: zorg ervoor dat het veld boven de studenten (en weegfactortext) leeg is en zorg ervoor dat de weegfactorrij begint met "Weegfactor"
                                    img.w-100(
                                        v-fullscreen-img="{scaleOnHover: true}"
                                        src="@/assets/lege_student_row.png"
                                    )
                                    p Stap 3: U kunt op elk tablad een aparte toets zetten, die worden dan tegelijkertijd ingeladen. U kunt gemakkelijk switchen met de selector hierboven (omhoog scrollen en dan verschijnt een selector)
                    v-file-input(
                        v-model="excel_file"
                        label="excel"
                        show-size
                    )
                    v-btn(
                        @click="loadClassData()"
                    ) Laad in 
                    //- p {{ excel_file }}
                    div.mt-4(v-if="tests.length > 0")
                        h2 Toetsen
                        v-list()
                            v-list-item(
                                v-for="(test, index) in tests"
                                :title="test.name"
                                @click="()=> {}"
                            )   

                                template(v-slot:append)
                                    v-icon(
                                        icon="mdi-delete"
                                        color="red"
                                        @click="this.tests.splice(index, 1); "
                                    )
                                

                v-divider(vertical)
                v-col.v-col-12.v-col-sm-4
                    div(v-if="is_loaded")
                        h1 {{ test.name }}
                        v-divider
                        p vragen: {{test.questions.length}}
                        p studenten: {{test.students.length}}
                        v-divider
                        v-list(v-model="selected_question_number" density="compact")
                            v-list-item(
                                v-for="(question, i) in test.questions"
                                :key="question.question_number"
                                @click="selected_question_number = question.question_number"
                            )   
                                template(v-slot:prepend)
                                    v-list-item-action(start)
                                        v-checkbox(readonly density="compact" :modelValue="question.question_number == selected_question_number")

                                v-list-item-title Vraag {{ question.question_number }} 
                                    
                                ul.pl-5()
                                    li(v-for="section in question.sections") {{ section.name }}

                                
                v-divider(vertical)
                v-col.v-col-12.v-col-sm-4
                    div(v-if="is_loaded && selected_question ")
                        h2 Vraag {{ selected_question.question_number }}
                        v-divider
                        h4 Leerdoelen:
                        v-list(density="compact")
                            v-list-item(v-for="(section,i) in sections")
                                template(v-slot:prepend)
                                    v-list-item-action(start)
                                        v-checkbox(
                                            readonly 
                                            density="compact" 
                                            :modelValue="selected_question.sections.map(e => e.id).includes(section.id)"
                                            @click="clickSectionCheckbox(section)"
                                        )

                                v-list-item-title 
                                    v-text-field(
                                        class="mt-2"
                                        v-model="sections[i].name" 
                                        label="Naam leerdoel"
                                        density="compact"
                                        variant="outlined"
                                    )
                                    
                                template(v-slot:append)
                                    v-icon(icon="mdi-delete" @click="deleteSection(section)" color="red")
                                
                                v-list-item-subtitle 
                                    v-text-field(
                                        class="mt-2"
                                        v-model="sections[i].beschrijving" 
                                        label="Beschrijving leerdoel"
                                        density="compact"
                                        variant="outlined"
                                    )
                                    
                                
                        v-btn(
                            prepend-icon="mdi-plus"
                            @click="sections.push(new data_classes.Section({}))"
                        ) Nieuw leerdoel
                        
        v-window-item(value="analyse" style="overflow-y: scroll")
            div.d-flex.flex-wrap.w-100
                div(style="width: 200px")
                    v-list()
                        v-list-item(
                            title="Type analyse"
                        )
                        v-divider
                        
                        v-list-item(
                            v-for="item in [{'title': 'Student', 'value': 'student'}, {'title': 'Vraag', 'value': 'question'}, {'title': 'Leerdoel', 'value': 'section'}, ]"
                            :title="item.title"
                            :value="item.value"
                            :active="selected_analysis_type == item.value"
                            @click="selected_analysis_type = item.value; selected_analysis_item_id = 'overview'"
                        )

                v-divider(vertical)
                div(style="width: 200px;").h-100
                    v-list().h-100
                        v-list-item(
                            title="Selecteer specifiek"
                        )
                        v-divider
                        v-list-item(
                            title="Overzicht"
                            :value="'overview'"
                            @click="selected_analysis_item_id = 'overview'"
                            :active="selected_analysis_item_id == 'overview'"
                        )
                        v-divider

                        v-list-item(
                            v-for="item in selected_nav_list_items"
                            :title="item.title"
                            :value="item.id"
                            :active="selected_analysis_item_id == item.id"
                            @click="selected_analysis_item_id = item.id"
                        )

                v-divider(vertical)

                div(style="flex: 1; max-width: calc(100% - 400px); min-width: 400px")
                    v-select(v-model="test.data_type" :items="['points', 'percent']")
                    div.pa-2(style="max-height: calc(100% - 56px); overflow-y: scroll;")
                        div(
                            v-if="selected_analysis_item_id == 'overview'"
                        )
                            h1 Overview
                            v-divider
                            //- div(v-if="selected_analysis_type == 'student'")
                            //- div(v-if="selected_analysis_type == 'question'")
                            //- div(v-if="selected_analysis_type == 'section'")

                                //- :headers="resultHeaders"
                            v-expansion-panels(multiple)
                                v-expansion-panel()
                                    v-expansion-panel-title Tabel
                                    v-expansion-panel-text
                                        v-data-table(
                                            :items="resultOverviewItems"
                                            density="compact"
                                        )
                                            template(v-slot:item="{ item }")
                                                tr  
                                                    td(v-for="val in Object.values(item)") 
                                                        | {{ (isNumeric(val) && decCount(val) > 4) ? Math.round(val * 1000) / 1000 : val }}
                                v-expansion-panel()
                                    v-expansion-panel-title Extra
                                    v-expansion-panel-text
                                        div(v-if="selected_analysis_type == 'student'")
                                            b Als studenten
                                            p download hier een pdf met uitprintbare resultaten (per vraag en per leerdoel) per student
                                            b Als vraag
                                            p zie als docent hier welke vragen het slechts gemaakt zijn
                                            b Als leerdoel
                                            p zie als docent hier welke leerdoel het slechts gemaakt zijn
                                v-expansion-panel()
                                    v-expansion-panel-title Grafiek
                                    v-expansion-panel-text 
                                        //- pre {{ chartSeries}}        
                                        apexchart(
                                            :options="chartOptions"
                                            :series="chart_series"
                                            height="400px"
                                        )
                                        p  Î¼: {{ groupNormalDistribution.mean }}
                                        p  Ïƒ: {{ groupNormalDistribution.standard_deviation }}
                                        v-btn(
                                            @click="chart_series = this.chartSeries"
                                        ) Bereken
                                        v-divider
                                        div
                                            h3 Bereken dingen test
                                            v-divider
                                            h4 NormalPDF(x, Î¼, Ïƒ)
                                            v-text-field(
                                                type="number"
                                                label="x"
                                                v-model="calculate_normal.pdf_x"
                                                :step="0.1"
                                            )
                                            b
                                            |  = {{ calculateNormalResults.pdf }}
                                            h4 NormalCDF(x, Î¼, Ïƒ)
                                            v-text-field(
                                                type="number"
                                                label="x"
                                                v-model="calculate_normal.cdf_x"
                                                :step="0.1"
                                            )
                                            b
                                            |  = {{ calculateNormalResults.cdf }}
                                            h4 InvNorm(opp, Î¼, Ïƒ, 'LEFT'|'RIGHT'|'CENTER')
                                            v-slider(
                                                type="number"
                                                label="opp"
                                                v-model="calculate_normal.inv_opp"
                                                min="0"
                                                max="1"
                                            )
                                            v-select(
                                                :items="['LEFT','RIGHT','CENTER']"
                                                label="type"
                                                v-model="calculate_normal.inv_type"
                                            )
                                            b 
                                            | = {{ calculateNormalResults.inv }}
                                v-expansion-panel
                                    v-expansion-panel-title Correlaties
                                    v-expansion-panel-text
                                        apexchart(
                                            width="800px"
                                            height="600px"
                                            :options="heatmap_options"
                                            :series="heatmapData"
                                        )

                        div(
                            v-else-if="selected_item"
                        )   
                            div(v-if="selected_analysis_type == 'student'")
                                h1 {{ selected_item.name }}
                            div(v-if="selected_analysis_type == 'question'")
                                h1 {{ selected_item.name }}
                            div(v-if="selected_analysis_type == 'section'")
                                h1 {{ selected_item.name }}



            

        // Page "Bewerk"-code starts here!
        v-window-item(value="edit")

</template>

<script>
// Data 
import data_classes from '@/classes'
import {  excelFileToJSON, sum, uncircularStringify, decCount, isNumeric } from '@/helpers'


// Components


export default {
    name: 'AnalisisView',
    components: {
    
    },
    props: {
    
    },
    emits: [],
    setup() {
        return { data_classes, uncircularStringify, decCount, isNumeric }
    },
    data(){
        return {
            selected_tab: 'load',

            // loading tab
            excel_file: null,
            test_data: {
                VoorbeeldToets: [
    {
        "__EMPTY": "Student_1",
        "Q1": 6,
        "Q2": 1,
        "Q3": 1,
        "Q4": 5,
        "Q5": 1,
        "Q6": 4,
        "Q7": 6,
        "Q8": 3,
        "Q9": 3,
        "Q10": 4,
        "Total": 34
    },
    {
        "__EMPTY": "Student_2",
        "Q1": 6,
        "Q2": 0,
        "Q3": 1,
        "Q4": 11,
        "Q5": 15,
        "Q6": 3,
        "Q7": 3,
        "Q8": 5,
        "Q9": 3,
        "Q10": 9,
        "Total": 56
    },
    {
        "__EMPTY": "Student_3",
        "Q1": 8,
        "Q2": 1,
        "Q3": 0,
        "Q4": 8,
        "Q5": 7,
        "Q6": 2,
        "Q7": 2,
        "Q8": 7,
        "Q9": 1,
        "Q10": 10,
        "Total": 46
    },
    {
        "__EMPTY": "Student_4",
        "Q1": 11,
        "Q2": 4,
        "Q3": 4,
        "Q4": 12,
        "Q5": 5,
        "Q6": 0,
        "Q7": 6,
        "Q8": 5,
        "Q9": 1,
        "Q10": 4,
        "Total": 52
    },
    {
        "__EMPTY": "Student_5",
        "Q1": 5,
        "Q2": 2,
        "Q3": 5,
        "Q4": 12,
        "Q5": 11,
        "Q6": 4,
        "Q7": 2,
        "Q8": 5,
        "Q9": 1,
        "Q10": 10,
        "Total": 57
    },
    {
        "__EMPTY": "Student_6",
        "Q1": 7,
        "Q2": 1,
        "Q3": 7,
        "Q4": 6,
        "Q5": 11,
        "Q6": 3,
        "Q7": 0,
        "Q8": 6,
        "Q9": 6,
        "Q10": 9,
        "Total": 56
    },
    {
        "__EMPTY": "Student_7",
        "Q1": 10,
        "Q2": 2,
        "Q3": 14,
        "Q4": 6,
        "Q5": 7,
        "Q6": 2,
        "Q7": 0,
        "Q8": 8,
        "Q9": 6,
        "Q10": 7,
        "Total": 62
    },
    {
        "__EMPTY": "Student_8",
        "Q1": 6,
        "Q2": 0,
        "Q3": 0,
        "Q4": 12,
        "Q5": 8,
        "Q6": 1,
        "Q7": 5,
        "Q8": 8,
        "Q9": 4,
        "Q10": 7,
        "Total": 51
    },
    {
        "__EMPTY": "Student_9",
        "Q1": 10,
        "Q2": 2,
        "Q3": 2,
        "Q4": 12,
        "Q5": 8,
        "Q6": 1,
        "Q7": 7,
        "Q8": 5,
        "Q9": 0,
        "Q10": 7,
        "Total": 54
    },
    {
        "__EMPTY": "Student_10",
        "Q1": 6,
        "Q2": 1,
        "Q3": 4,
        "Q4": 8,
        "Q5": 9,
        "Q6": 0,
        "Q7": 0,
        "Q8": 8,
        "Q9": 4,
        "Q10": 2,
        "Total": 42
    },
    {
        "__EMPTY": "Student_11",
        "Q1": 5,
        "Q2": 0,
        "Q3": 3,
        "Q4": 7,
        "Q5": 7,
        "Q6": 2,
        "Q7": 5,
        "Q8": 5,
        "Q9": 3,
        "Q10": 5,
        "Total": 42
    },
    {
        "__EMPTY": "Student_12",
        "Q1": 8,
        "Q2": 2,
        "Q3": 6,
        "Q4": 5,
        "Q5": 6,
        "Q6": 4,
        "Q7": 0,
        "Q8": 8,
        "Q9": 7,
        "Q10": 10,
        "Total": 56
    },
    {
        "__EMPTY": "Student_13",
        "Q1": 5,
        "Q2": 2,
        "Q3": 1,
        "Q4": 13,
        "Q5": 14,
        "Q6": 4,
        "Q7": 3,
        "Q8": 5,
        "Q9": 5,
        "Q10": 3,
        "Total": 55
    },
    {
        "__EMPTY": "Student_14",
        "Q1": 8,
        "Q2": 0,
        "Q3": 5,
        "Q4": 8,
        "Q5": 7,
        "Q6": 0,
        "Q7": 2,
        "Q8": 7,
        "Q9": 6,
        "Q10": 8,
        "Total": 51
    },
    {
        "__EMPTY": "Student_15",
        "Q1": 10,
        "Q2": 6,
        "Q3": 2,
        "Q4": 8,
        "Q5": 4,
        "Q6": 5,
        "Q7": 7,
        "Q8": 4,
        "Q9": 5,
        "Q10": 10,
        "Total": 61
    },
    {
        "__EMPTY": "Student_16",
        "Q1": 8,
        "Q2": 3,
        "Q3": 3,
        "Q4": 4,
        "Q5": 12,
        "Q6": 5,
        "Q7": 5,
        "Q8": 4,
        "Q9": 2,
        "Q10": 3,
        "Total": 49
    },
    {
        "__EMPTY": "Student_17",
        "Q1": 9,
        "Q2": 4,
        "Q3": 4,
        "Q4": 13,
        "Q5": 6,
        "Q6": 2,
        "Q7": 0,
        "Q8": 4,
        "Q9": 6,
        "Q10": 6,
        "Total": 54
    },
    {
        "__EMPTY": "Student_18",
        "Q1": 10,
        "Q2": 3,
        "Q3": 12,
        "Q4": 9,
        "Q5": 4,
        "Q6": 2,
        "Q7": 0,
        "Q8": 8,
        "Q9": 4,
        "Q10": 6,
        "Total": 58
    },
    {
        "__EMPTY": "Student_19",
        "Q1": 7,
        "Q2": 3,
        "Q3": 1,
        "Q4": 12,
        "Q5": 12,
        "Q6": 1,
        "Q7": 0,
        "Q8": 5,
        "Q9": 5,
        "Q10": 7,
        "Total": 53
    },
    {
        "__EMPTY": "Student_20",
        "Q1": 9,
        "Q2": 5,
        "Q3": 4,
        "Q4": 6,
        "Q5": 12,
        "Q6": 2,
        "Q7": 6,
        "Q8": 8,
        "Q9": 2,
        "Q10": 10,
        "Total": 64
    },
    {
        "__EMPTY": "Weegfactor",
        "Q1": 11,
        "Q2": 8,
        "Q3": 17,
        "Q4": 19,
        "Q5": 15,
        "Q6": 12,
        "Q7": 17,
        "Q8": 9,
        "Q9": 11,
        "Q10": 14,
        "Total": 133
    }
]
            },
            selected_test_id: null,
            tests: [],

            // loading tab data
            selected_question_number: null,
            sections: [],

            // analysis tab data
            selected_analysis_type: 'student',
            selected_analysis_item_id: null,

            // table
            result_data_type: 'points',

            // heat map
            comparision_type: 'question',
            heatmap_options: {
                chart: {
                    type: 'heatmap',
                },
                dataLabels: {
                    enabled: true,
                    formatter: function (val, opt) {
                        return Math.round(val * 1000) / 1000
                    },
                    dropShadow: {
                        // enabled: true
                    }
                },
                colors: ["#008FFB"],
                heatmap: {

                    min: -1,
                    max: 1
                },
                tooltip: {
                    theme: 'dark',
                    x: {
                        show: true,
                        formatter: function (value, { series, seriesIndex, dataPointIndex, w }) {
                            return 'Cor(item1, item2) = '
                        }
                    },
                    y: {
                        title: {
                            formatter: function () {
                                return ''
                            }
                        }
                    }
                }
            },
            gradechart_options: {
                chart: {
                    type: 'line',


                },

                stroke: {
                    curve: 'straight',
                },
                tooltip: {
                    theme: 'dark'
                },


            },
            calculate_normal: {
                pdf_x: 0,                
                cdf_x: 0,
                inv_opp: 0.2,
                inv_type: 'LEFT',
            },
            chart_series: []

        }
    },
    computed: {
        test: {
            get(){
                const index = this.tests.findIndex(e => e.id == this.selected_test_id)

                if (index != -1){
                    return this.tests[index]
                }

                return new data_classes.Test({id: -1})

            },
            set(val){
                const index = this.tests.findIndex(e => e.id == val.id)

                if (index != -1){
                    this.tests[index] = val
                }
            }
        },
        is_loaded(){
            return (this.tests.length > 0) 
                    && (this.test.id != -1) 
        },
        selected_question_index(){return this.test.questions.map(e => e.question_number).indexOf(this.selected_question_number)},
        selected_question: {
            get(){
                const index = this.selected_question_index
                if (index != -1){
                    return this.test.questions[index]
                }
                return null
            },
            set(val){
                const index = this.selected_question_index
                if (index != -1){
                    // set without changing reference
                    return this.test.questions[index].set(val)
                }
            }
        },
        selected_nav_list_items(){
            switch (this.selected_analysis_type) {
                case "student":
                    return this.test.students.map(e => {return {title: e.name, id: e.id, item: e}})
                    break;
                case "question":
                    return this.test.questions.map(e => {return {title: 'Vraag '+e.question_number, id: e.id, item: e}})
                    break;
                case "section":
                    return this.test.sections.map(e => {return {title: e.name, id: e.id, item: e}})
                    break;
                                    
                default:
                    return []
                    break;
            }
        },
        selected_item:{
            get(){
                return this.selected_nav_list_items.find( e=> e.id == this.selected_analysis_item_id)
            },
            set(val){
                const index = this.test[selected_analysis_type+"s"].findIndex(e=>e.id==this.selected_analysis_item_id)
                if (index != -1){
                    this.test[selected_analysis_type+"s"][index] = val
                }
            }
        },
        selected_item_results(){
            return this.selectedTypeGroupsById[this.selected_analysis_item_id]
        },
        
        heatmapData(){
            const series = []
            let items = []
            let name_key = ""
            switch (this.selected_analysis_type) {
                case "question":
                    items = this.test.questions.sort((a,b) => a.question_number - b.question_number)
                    name_key = "question_number"

                    break;
                case "student":
                    items = this.test.students
                    name_key = 'name'
                case "section":
                    name_key = this.test.sections
                    name_key = "name"
                default:
                    break;
            }
            items.forEach(item1 => {
                const serie = {
                    name: item1[name_key],
                    data: []
                }

                items.forEach(item2 => {
                    if (item1.id == item2.id) {
                        var result = 1
                    } else {
                        var result = this.test.results.getTypeCorrelation(
                            this.selected_analysis_type,
                            item1.id,
                            item2.id
                        )
                    }

                    serie.data.push(result)
                })

                series.push(serie)
            })

            
            return series
            
        },
        gradechartData(){
            const grade_series = [...Array(20).keys()].map(e => e * 0.5);

            return [{
                type: 'line',
                data: grade_series.map(e => {return  {
                    x: Math.round(e / 10) * 10,
                    y: this.test.grade_formula.method(e / 10)
                }})
            }]

        },

        selectedTypeGroupsById(){
            const grouped_data = {}
            switch (this.selected_analysis_type) {
                case "student":

                    this.test.students.forEach(e => {
                        grouped_data[e.id] = this.test.results.getStudentResults(e.id)
                    })
                    break;
                case "question":
                    this.test.questions.forEach(e => {
                        grouped_data[e.id] = this.test.results.getQuestionResults(e.id)
                    })
                    break;
                case "section":
                    this.test.sections.forEach(e => {
                        grouped_data[e.id] = this.test.results.getSectionResults(e.id)
                    })                
                    break;
                                    
                default:
                    break;
            }

            return grouped_data
        },
        resultOverviewItems(){
            const grouped_data = this.selectedTypeGroupsById
            return Object.keys(grouped_data).map(item_id => {
                const data = grouped_data[item_id]

                let name = ""
                if (this.selected_analysis_type == "student"){
                    const student = this.test.students.find(e => e.id == item_id)
                    name = student.name
                }
                if (this.selected_analysis_type == "question"){
                    const question = this.test.questions.find(e => e.id == item_id)
                    name = "Vraag "+ question.question_number
                }
                if (this.selected_analysis_type == "section"){
                    const section = this.test.sections.find(e => e.id == item_id)
                    name = section.name
                }
                return {
                    name,
                    average: data.average,
                    standard_dev: data.standard_deviation,
                    grade: data.grade,
                    total_points: data.points
                }
            })
        },
        groupNormalDistribution(){
            return new data_classes.NormalDistribution({values: Object.values(this.selectedTypeGroupsById).map(e=> e.average)})
        },
        calculateNormalResults(){
            return {
                pdf: this.groupNormalDistribution.pdf(this.calculate_normal.pdf_x),
                cdf: this.groupNormalDistribution.pdf(this.calculate_normal.cdf_x),
                inv: this.groupNormalDistribution.invNorm(this.calculate_normal.inv_opp, this.calculate_normal.inv_type),

            }
        },
        chartOptions(){
            return {

                chart: {
                    type: 'line',
                    zoom: {
                        enabled: false
                    }

                },
                yaxis: {
                    labels: {formatter: function(value) {return value.toFixed(3);}}
                },
                stroke: {
                    curve: 'monotoneCubic',
                },
                tooltip: {
                    enabled: true,
                    enabledOnSeries: [2,3,4,5],
                    theme: 'dark'
                },
                dataLabels: {
                    enabled: true,
                    enabledOnSeries: []
                },
            }
        },
        pdfSeries(){
            const pdf_series = {
                type: 'scatter',
                name: 'pdf',

                chart: {
                    stroke: {
                        width: '3px'
                    },
                    tooltips:{
                        enabled: true,
                        theme: 'dark'
                    },
                },
                data: [
                    {
                        x: this.calculate_normal.pdf_x,
                        y: this.calculateNormalResults.pdf
                    }
                ]
            }
            return pdf_series
        },
        cdfSeries(){
            const cdf_series = {
                type: 'area',
                name: 'cdf',

                tooltips:{
                    enabled: true,
                    theme: 'dark'
                },
                data: this.groupNormalData.filter(e => e.x < this.calculate_normal.cdf_x)
            }
            return cdf_series
        },
        invSeries(){

            const result = this.calculateNormalResults.inv
            const invnorm_series = {
                type: 'area',
                name: 'inv',
                tooltips:{
                    enabled: true,
                    theme: 'dark'
                },
                data: this.groupNormalData.filter(e => {
                    if (this.calculate_normal.inv_type =='LEFT') {
                        return e.x <= result
                    }
                    if (this.calculate_normal.inv_type =='RIGHT') {
                        return e.x >= result
                    }
                    if (this.calculate_normal.inv_type =='CENTER') {
                        return e.x >= result[0] && e.x < result[1]
                    }
                })
            }
            let data = []
            if (this.calculate_normal.inv_type =='LEFT' || this.calculate_normal.inv_type =='RIGHT') {
                data = [{
                    x: result,
                    y: this.groupNormalDistribution.pdf(result)
                }]
            }

            if (this.calculate_normal.inv_type =='CENTER') {
                data = [
                    {
                        x: result[0],
                        y: this.groupNormalDistribution.pdf(result[0])
                    },
                    {
                        x: result[1],
                        y: this.groupNormalDistribution.pdf(result[1])
                    },
                ]
            }
            const invnorm_x_series = {
                type: 'scatter',
                name: 'inv_x',
                tooltips:{
                    enabled: true,
                    theme: 'dark'
                },
                data
            }
            return [invnorm_series, invnorm_x_series]
        },
        groupNormalData(){
            const normal = this.groupNormalDistribution
            const sigma_range = 4
            const diff = sigma_range * normal.standard_deviation
            const range_start = normal.mean - diff
            const n = 100
            const step = (2 * diff) / n

            const normal_data =  [...Array(n).keys()].map((i) => {
                const x = range_start + i*step
                return {
                    x,
                    y: normal.pdf(x) 
                }      
            })
            return normal_data
        },
        chartSeries(){


            const normal_graph = {
                type: 'line',
                chart: {
                    tooltips: {
                        enabled: false,
                    },
                },
                data: this.groupNormalData
            }

            // caculations
            // pdf
            
            // cdf
            
            // invNorm
            
            


            return [
                normal_graph,
                this.pdfSeries,
                this.cdfSeries,
                ...this.invSeries,
            ]
        }
        
        
    },
    methods: {
        addTestFromJSON(name, data){
            const questions = []
            const STUDENT_ID_KEY = '__EMPTY'
            const POINT_ROW_NAME = "weegfactor"

            const canBeQuestion = (q_name) => {
                const lower_key = q_name.toLowerCase()
                return lower_key.startsWith("q") || lower_key.startsWith("v")
            }
            const getQuestionNumber = (q_name) => {
                return  Number(q_name.replace(/\D/g,''))
            }

            const max_point_row = data.find(e => e[STUDENT_ID_KEY].toLowerCase() == POINT_ROW_NAME ) || {}

            Object.keys(data[data.length - 1]).forEach(key => {
                // Question or Vraag
                if (canBeQuestion(key)){
                    const max_points = max_point_row[key]

                    // only numerals
                    questions.push(new data_classes.Question({
                        question_number:getQuestionNumber(key),
                        total_points: max_points
                    }))
                }
            })

            const students = []

            const result_bundle = new data_classes.ResultBundle({})
            data.forEach(row => {
                const student_id = row[STUDENT_ID_KEY]
                if (student_id.toLowerCase() == POINT_ROW_NAME){
                    return
                }

                const current_student = new data_classes.Student({
                    id: student_id,
                    name: student_id
                })
                students.push(current_student)

                Object.entries(row).forEach(([question_id, points]) => {
                    if (canBeQuestion(question_id)){
                        const result = new data_classes.Result({
                            question: questions.find(e => e.question_number == getQuestionNumber(question_id)) || new data_classes.Question({}),
                            student: current_student,
                            points: points
                        })

                        result_bundle.addResult(result)
                    }
                })
            })


            const new_test = new data_classes.Test({
                results: result_bundle,
                name,
                questions: questions,
                students: students
            })
            new_test.results.test = this.test
            console.log(new_test)
            this.tests.push(new_test)
            this.selected_test_id = new_test.id
        },
        async loadClassData(){
            const data = this.excel_file ? await excelFileToJSON(this.excel_file) : this.test_data
            Object.keys(data).forEach(name => {
                console.log(name, data[name])
                this.addTestFromJSON(name, data[name])
            })
            
        },
        clickSectionCheckbox(section){
            const index = this.selected_question.sections.indexOf(section)
            // found
            if (index != -1) {
                this.selected_question.sections.splice(index, 1)
            } else {
                // not found
                this.selected_question.sections.push(section)

            }
        },
        deleteSection(section){
            if (window.confirm("Weet je zeker dat je " + section.name + " overal wilt verwijderen")) {
                const index = this.sections.indexOf(section)

                this.sections.splice(index,1)
                
                this.test.questions.forEach( (question, question_index) => {
                    question.sections.forEach((question_section, section_index) => {
                        if (section.id == question_section.id){
                            this.test.questions[question_index].sections.splice(section_index, 1)
                        }
                    })
                })
            }
            
            
        }
    },
    watch: {
        excel_file(){
            this.loadClassData
        }
    },
    // created() {
    
    // },
    async mounted() {
        await this.loadClassData()
        this.selected_tab = 'load'


        // const normal = new data_classes.NormalDistribution({mean: 10, standard_dev: 4})
        // normal.invNorm(0.3)
    },
    
    
}
</script>
    
<style scoped>
.mh-100 {
    max-height: 100%
}
</style>
<style>
body {
    overflow: hidden; /* Hide scrollbars */
}
</style>

# ======================
# File: src\views\FullView.vue
# ======================

<template lang="pug">
MainLayout
</template>

<script>
// Data 
import MainLayout from '@/components/full_view/MainLayout.vue'

// Components

export default {
    name: 'FullView',
    components: {
        MainLayout
    },
    props: {

    },
    emits: [],
    setup() {
        return {

        }
    },
    data() {
        return {
            
        }
    },
    computed: {
        
    },
    methods: {
        

    },
    watch: {

    },
    // created() {

    // },
    async mounted() {
    


    },


}

</script>

<style scoped>
</style>


# ======================
# File: src\views\HomeView.vue
# ======================

<template lang="pug">
canvas#hero-canvas
</template>

<script>
import * as THREE from 'three';
import { onMounted, onBeforeUnmount, ref, reactive, getCurrentInstance, toRaw } from 'vue';

export default {
    name: 'ThreejsHero',
    components: {

    },
    props: {

    },
    emits: [],
    setup() {
        const canvasRef = ref(null);
        let ambientLight, pointLight, raycaster, clickPlane;
        const waves = reactive([]);
        const spheresGlobalData = reactive([]);
        const layerData = reactive([
            { zOffset: 0,    parallaxFactor: 1,   group: new THREE.Group(), count: 5, basePosition: new THREE.Vector3(0, 0, 0) },
            { zOffset: -5,   parallaxFactor: 0.7, group: new THREE.Group(), count: 5, basePosition: new THREE.Vector3(0, 0, -5) },
            { zOffset: -10,  parallaxFactor: 0.5, group: new THREE.Group(), count: 5, basePosition: new THREE.Vector3(0, 0, -10) },
            { zOffset: -15,  parallaxFactor: 0.3, group: new THREE.Group(), count: 3, basePosition: new THREE.Vector3(0, 0, -15) },
            { zOffset: -20,  parallaxFactor: 0.2, group: new THREE.Group(), count: 2, basePosition: new THREE.Vector3(0, 0, -20) }
        ]);
        const mouse = reactive(new THREE.Vector2());
        let targetScrollProgress = 0;
        let currentScrollProgress = 0;

        // Get current Vue instance proxy
        const instance = getCurrentInstance();
        const proxy = instance.proxy;

        class EnergyWave {
            constructor(x, y, z) {
                this.center = new THREE.Vector3(x, y, z);
                this.radius = 0;
                this.maxRadius = 30;
                this.speed = 0.2;
                this.strength = 1;
                this.life = 1;
            }

            update() {
                this.radius += this.speed;
                this.life = Math.max(0, 1 - this.radius / this.maxRadius);
                return this.life > 0;
            }
        }


        const initThreeJS = () => {
            const canvas = canvasRef.value;

            /**
             * SCENE, CAMERA, RENDERER
             */
            proxy.$scene = new THREE.Scene();
            proxy.$camera = new THREE.PerspectiveCamera(
                55,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            proxy.$scene.add(toRaw(proxy.$camera));

            proxy.$renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            proxy.$renderer.setSize(window.innerWidth, window.innerHeight);
            proxy.$renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            /**
             * LIGHTS
             */
            ambientLight = new THREE.AmbientLight(0x3b82f6, 0.3);
            proxy.$scene.add(ambientLight);

            pointLight = new THREE.PointLight(0xffffff, 0.3, 100);
            pointLight.position.set(10, 20, 10);
            proxy.$scene.add(pointLight);

            /**
             * LAYER SETUP
             */
            layerData.forEach(layer => {
                layer.group.position.copy(layer.basePosition);
                proxy.$scene.add(toRaw(layer.group));
            });

            /**
             * SPHERE GENERATION
             */
            layerData.forEach(layer => {
                const BOUNDS = {
                    minX: -10,
                    maxX: 10,
                    minY: -6,
                    maxY: 6,
                    minZ: -3,
                    maxZ: 3
                };

                for (let i = 0; i < layer.count; i++) {
                    const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x3b82f6,
                        transparent: true,
                        opacity: 0.6,
                        emissive: 0x000000,
                        emissiveIntensity: 0
                    });

                    const sphere = new THREE.Mesh(geometry, material);

                    const posX = THREE.MathUtils.randFloat(BOUNDS.minX, BOUNDS.maxX);
                    const posY = THREE.MathUtils.randFloat(BOUNDS.minY, BOUNDS.maxY);
                    const posZ = THREE.MathUtils.randFloat(BOUNDS.minZ, BOUNDS.maxZ);
                    sphere.position.set(posX, posY, posZ);

                    const speedX = THREE.MathUtils.randFloat(-0.02, 0.02);
                    const speedY = THREE.MathUtils.randFloat(-0.02, 0.02);
                    const speedZ = THREE.MathUtils.randFloat(-0.02, 0.02);

                    layer.group.add(sphere);

                    spheresGlobalData.push({
                        mesh: sphere,
                        velocity: new THREE.Vector3(speedX, speedY, speedZ),
                        baseOpacity: material.opacity,
                        originalScale: new THREE.Vector3(1, 1, 1),
                        bounds: BOUNDS,
                        layerParallax: layer.parallaxFactor,
                        layer: layer
                    });
                }
            });

            /**
             * CLICK EVENT FOR WAVE EFFECT
             */
            raycaster = new THREE.Raycaster();
            clickPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        };

        const onClick = (event) => {
            const mousePos = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            // Update plane normal based on camera position
            clickPlane.normal.copy(toRaw(proxy.$camera).position).normalize();

            raycaster.setFromCamera(mousePos, toRaw(proxy.$camera));
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(clickPlane, intersection);

            waves.push(new EnergyWave(intersection.x, intersection.y, intersection.z));
        };

        const onMouseMove = (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -((event.clientY / window.innerHeight) * 2 - 1);
        };

        const onScroll = () => {
            const docHeight = document.body.scrollHeight - window.innerHeight;
            const fraction = docHeight > 0 ? window.scrollY / docHeight : 0;
            targetScrollProgress = THREE.MathUtils.clamp(fraction, 0, 1);
        };

        const onWindowResize = () => {
            proxy.$camera.aspect = window.innerWidth / window.innerHeight;
            proxy.$camera.updateProjectionMatrix();
            proxy.$renderer.setSize(window.innerWidth, window.innerHeight);
        };

        const animate = () => {
            requestAnimationFrame(animate);

            // Smooth scroll interpolation
            currentScrollProgress += (targetScrollProgress - currentScrollProgress) * 0.05;

            // Camera movement
            const fullOrbit = 2 * Math.PI;
            const angle = currentScrollProgress * fullOrbit;
            const orbitRadius = 20;
            const camX = orbitRadius * Math.cos(angle);
            const camZ = orbitRadius * Math.sin(angle);
            const camY = 5 + currentScrollProgress * 10;

            proxy.$camera.position.set(camX, camY, camZ);
            proxy.$camera.lookAt(0, 0, 0);

            // Update waves
            for (let i = waves.length - 1; i >= 0; i--) {
                if (!waves[i].update()) {
                    waves.splice(i, 1);
                }
            }

            // Color transition
            const colorLight = new THREE.Color(0x3b82f6);
            const colorDark = new THREE.Color(0x1e40af);

            // Update layer positions based on scroll
            layerData.forEach(layer => {
                const parallaxOffset = currentScrollProgress * 5 * layer.parallaxFactor;
                layer.group.position.z = layer.basePosition.z + parallaxOffset;
            });

            // Update spheres
            spheresGlobalData.forEach(sphereData => {
                const { mesh, velocity, bounds, layerParallax, layer } = sphereData;

                // Convert sphere position to world space for mouse interaction
                const worldPos = new THREE.Vector3();
                sphereData.mesh.getWorldPosition(worldPos);

                const mouseAttractRadius = 3;
                const mouseAttractStrength = 0.001 * layerParallax;
                const mouseX3D = mouse.x * 10;
                const mouseZ3D = mouse.y * 10;

                const dx = mouseX3D - worldPos.x;
                const dz = mouseZ3D - worldPos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < mouseAttractRadius) {
                    const force = (mouseAttractRadius - dist) * mouseAttractStrength;
                    velocity.x -= dx * force;
                    velocity.z -= dz * force;
                }

                // Wave effect
                let totalWaveEffect = 0;
                waves.forEach(wave => {
                    const distanceToWave = worldPos.distanceTo(toRaw(wave.center));
                    const waveZone = Math.abs(distanceToWave - wave.radius);

                    if (waveZone < 2) {
                        const waveIntensity = (1 - waveZone / 2) * wave.life * layerParallax;
                        totalWaveEffect = Math.max(totalWaveEffect, waveIntensity);
                    }
                });

                // Apply wave effect
                const scale = 1 + totalWaveEffect;
                mesh.scale.set(scale, scale, scale);
                mesh.material.emissive.setRGB(totalWaveEffect, totalWaveEffect, totalWaveEffect);

                // Random movement
                const noiseStrength = 0.0003;
                velocity.x += (Math.random() - 0.5) * noiseStrength;
                velocity.y += (Math.random() - 0.5) * noiseStrength;
                velocity.z += (Math.random() - 0.5) * noiseStrength;

                // Color update
                const currentColor = new THREE.Color().lerpColors(colorLight, colorDark, currentScrollProgress);
                mesh.material.color = currentColor;
            });

            proxy.$renderer.render(toRaw(proxy.$scene), toRaw(proxy.$camera));
        };

        const cleanup = () => {
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('resize', onWindowResize);
            window.removeEventListener('scroll', onScroll);
            window.removeEventListener('click', onClick);

            spheresGlobalData.forEach(sphereData => {
                sphereData.mesh.geometry.dispose();
                sphereData.mesh.material.dispose();
                proxy.$scene.remove(toRaw(sphereData.mesh));
            });

            proxy.$renderer.dispose();
        };


        onMounted(() => {
            canvasRef.value = document.getElementById('hero-canvas');
            initThreeJS();
            animate();
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('click', onClick);
        });

        onBeforeUnmount(() => {
            cleanup();
        });

        return {
            canvasRef
        };
    },
    data(){
        return {

        }
    },
    computed: {

    },
    methods: {

    },
    watch: {

    },
    // created() {

    // },


}
</script>

<style scoped>
canvas#hero-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* Place behind other content */
}
</style>

# ======================
# File: src\views\PdfView.vue
# ======================

<template lang="pug">
.pdf-viewer-container.h-100
    v-btn(href="/") Terug
    object.w-100(style="height: calc(100% - 40px)" :data="pdfSrc" type="application/pdf" class="internal")

</template>
<script>
import pws_pdf from '@/assets/PWS-NakijkenMetAi-JoostKoch-JonathanWijker.pdf'

export default {
  props: {
    pdfPath: {
       type: String,
       required: true,
     }
  },
  computed: {
    pdfSrc(){
       return pws_pdf //this.pdfPath;
    }
  }
}
</script>
<style scoped>
.pdf-viewer-container{
}
</style>

# ======================
# File: src\views\ScanView.vue
# ======================

<template lang="pug">
div
    v-stepper(v-model='selected_step_index' alt-labels :mobile="!$vuetify.display.mdAndUp" style="height: 100dvh")
        template.h-100(v-slot:default='{ prev, next }')
            v-stepper-header()
                template(
                    v-for='(step, index) in stepper_steps' 
                    :key='`${index}-step`'

                )
                    v-stepper-item(
                        :editable='true || index < selected_step_index'
                        :value="index"
                        :title="step"
                    ) 
                    v-divider(v-if='index !== stepper_steps.length-1')
            div.d-flex
                v-switch(v-model="is_qr_scanner" label="QR scanner") 

                v-btn(
                    @click="executeAll()"
                ) Execute all sequential
                v-btn(
                    @click="executeAllScanPage()"
                    :loading="all_loading_status=='started'"
                ) Execute all total (efficienter)
                v-btn(
                    :disabled="all_loading_status != 'loaded'"
                    @click="downloadJSON(pages.map(e => {return {page_id: e.id, result: e.total_result}}), 'all_page_data' )"
                    text="download all scanPage"
                )
            v-stepper-window.pa-0.ma-1(style="height: calc(100% - 190px); position: relative")
                v-stepper-window-item.pa-0.h-100(
                    v-for='(step, index) in stepper_steps' 
                    :key='`${index}-content`' 
                    :value='index'
                )
                    h2 {{ step, selected_page_id }}

                    div.h-100(v-if="step == 'load images'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            :hasDeleteButton="true"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                v-row.w-100
                                    v-col
                                        img(
                                            v-if="item.image"
                                            style="max-height: 100%; max-width: 100%"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.image" 
                                        )
                                    v-col.w-50
                                        v-btn(
                                            :loading="item.page.is_loading_all"
                                            text="Extraheer alles" @click="item.page.scanPage()"
                                        )
                                        v-btn(
                                            :disabled="item.page.is_loading_all"
                                            text="Download"
                                            @click="downloadJSON(item.page.total_result, 'PageData_'+item.page.id)"
                                        )

                                        v-textarea(
                                            :rows="2"
                                            :auto-grow="false"
                                            v-model="question_string" title="question"
                                        )
                                        div.d-flex
                                            v-btn(text="load question JSON" @click="context_data.questions = JSON.parse(question_string)")
                                            p {{ Object.keys(context_data.questions) }}
                                        v-textarea(
                                            :rows="2"
                                            :auto-grow="false"
                                            v-model="rubric_string" title="rubric"
                                        )
                                        div.d-flex
                                            v-btn(text="load rubric JSON" @click="context_data.rubrics = JSON.parse(rubric_string)")
                                            p {{ Object.keys(context_data.rubrics) }}
                                        v-textarea(
                                            :rows="2"
                                            :auto-grow="false"
                                            v-model="context_string" title="context"
                                        )
                                        div.d-flex
                                            v-btn(text="load context JSON" @click="context_data.contexts = JSON.parse(context_string)")
                                            p {{ Object.keys(context_data.contexts) }}

                        v-file-input(
                            label="Upload images"
                            v-model="uploaded_images"
                            multiple
                            accept="image/*"
                        )
                        v-btn(@click="addUploadedImages") Add Images
                    div.h-100(v-if="step == 'crop images'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                div.h-100.w-100.d-flex
                                    div.pa-3(style="height: 100%;")
                                        h2 Before
                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            
                                            v-if="item.page.base64Image"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.base64Image"
                                        )

                                    v-divider(vertical)
                                    div.pa-3(style="height: 100%; max-width: 50%; position: relative")
                                        RequestLoader(v-if="item.page.is_loading")
                                        h2 after

                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            
                                            v-if="item.page.croppedImage"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.croppedImage"
                                        )
                        v-btn(@click="cropImages") Crop Images
                    div.h-100(v-if="step == 'apply color correction'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                div.h-100.w-100.d-flex
                                    div.pa-3(style="height: 100%; width: 50%")
                                        h2 Before
                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.croppedImage"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.croppedImage"
                                        )

                                    v-divider(vertical)
                                    div.pa-3(style="height: 100%; width: 50%; position: relative")
                                        RequestLoader(v-if="item.page.is_loading")
                                        h2 after

                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.colorCorrected"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.colorCorrected" 
                                        )
                        v-btn(@click="applyColorCorrection") Apply Color Correction
                    div.h-100(v-if="step == 'extract qr sections and student id'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                h2 Student id
                                p {{ item.page.student_id  }}
                                v-divider
                                div.w-100.d-flex(style="height: calc(100% - 40px)")
                                    div.pa-3(style="height: 100%; width: 50%")
                                        h2 Before
                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.colorCorrected"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.colorCorrected" 
                                        )

                                    v-divider(vertical)
                                    div.pa-3(style="height: 100%; width: 50%; position: relative")
                                        RequestLoader(v-if="item.page.is_loading")
                                        h2 after

                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.squareImage"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.squareImage"
                                        )

                        v-btn(@click="extractQrSections") extract qr sections
                        v-btn(@click="extractStudentId") extract student id

                    div.h-100(v-if="step == 'detect squares'")
                        //- p {{ }}
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                h2 Student id
                                p {{ item.page.student_id  }}
                                v-divider
                                div.w-100.d-flex(style="height: calc(100% - 40px)")
                                    div.pa-3(style="height: 100%; width: 50%")
                                        h2 Before
                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.colorCorrected"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.colorCorrected" 
                                        )

                                    v-divider(vertical)
                                    div.pa-3(style="height: 100%; width: 50%; position: relative")
                                        RequestLoader(v-if="item.page.is_loading")
                                        h2 after

                                        img(
                                            style=" max-width: 100%; max-height: 100%"
                                            v-if="item.page.squareImage"
                                            v-fullscreen-img="{scaleOnHover: true}"
                                            :src="item.page.squareImage"
                                        )
                        v-btn(@click="detectSquares") Detect Squares
                        v-btn(@click="extractStudentId") extract student id

                    div.h-100(v-if="step == 'extract sections'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")
                                ImagesPreview(
                                    :items="item.page.sections.map(section => {return {section, id: section.id, image: section.full, title: section.id}})"
                                )
                                    template(v-slot:selected="{ item }")
                                        div.w-100.h-100.pa-3(style="overflow-y: scroll")
                                            div(v-if="item.section.full")
                                                h2 full
                                                img(
                                                    :src="item.section.full"
                                                    v-fullscreen-img="{scaleOnHover: true}"
                                                    style="max-height: 200px; max-width: 90%"
                                                )
                                                v-divider
                                            div(v-if="item.section.section_finder")
                                                h2 section_finder and studet id
                                                img(
                                                    :src="item.section.section_finder"
                                                    v-fullscreen-img="{scaleOnHover: true}"
                                                    style="max-height: 200px; max-width: 90%"

                                                )
                                                v-divider

                                            div(v-if="item.section.question_selector")
                                                h2 question_selector
                                                img(
                                                    :src="item.section.question_selector"
                                                    v-fullscreen-img="{scaleOnHover: true}"
                                                    style="max-height: 200px; max-width: 90%"
                                                )
                                                v-divider
                                            div(v-if="item.section.answer")
                                                h2 answer
                                                img(
                                                    :src="item.section.answer"
                                                    v-fullscreen-img="{scaleOnHover: true}"
                                                    style="max-height: 200px; max-width: 90%"

                                                )
                                                v-divider
                                            div(style="position: relative")
                                                RequestLoader(v-if="item.section.is_loading")

                                                h2 question number
                                                p {{ item.section.question_number }}
                                                v-divider
                                                h2 question data
                                                pre {{ item.section.question_number_data }}
                                                
                        //- ImagesPreview(
                        //-     :images="pages.map(page => page.sections.map(section => section.base64Image))"
                        //-     height="100%"
                            style="overflow-y: scroll"

                        //- )
                        v-btn(@click="extractQuestions") Extract question numbers
                    div.h-100(v-if="step == 'link answers'")
                        ImagesPreview(
                            :items="pages.map(page => {return {page, id:page.id, image: page.base64Image, title:page.id}})"
                            height="100%"
                            style="overflow-y: scroll"

                            @delete="pages.splice(pages.findIndex(e => e.id == $event), 1)"
                            v-model="selected_page_id"
                        )
                            template(v-slot:selected="{ item }")

                                ImagesPreview(
                                    :items="item.page.questions.map(question => {return {question, id: question.id, image: question.full, title: question.id}})"
                                )
                                    template(v-slot:selected="{ item }")
                                        div.w-100.h-100.pa-3(style="overflow-y: scroll")
                                            h2 question_number
                                            p {{ item.question.question_number}}

                                            v-divider    
                                            h2 full
                                            img(
                                                :src="item.question.base64Image"
                                                v-fullscreen-img="{scaleOnHover: true}"
                                                max-height="200px"
                                            )
                                            v-divider
                                            div(style="position: relative")
                                                RequestLoader(v-if="item.question.is_loading")

                                                h2 text
                                                pre {{ item.question.text }}
                                                v-divider
                                                h2 download individual
                                                v-btn(@click="downloadJSON(item.question.data, 'individual_question_'+item.question.id)") download
                                                v-btn(@click="downloadJSON({data:item.question.data, image: item.question.base64Image}, 'individual_question_with_image_'+item.question.id)") download with image
                                                v-divider
                                                h2 data
                                                pre {{ item.question.data }}
                                                
                        v-btn(@click="linkAnswers") link answers
                        v-btn(@click="extractText") extract text
                        v-btn(@click="downloadJSON(this.pages.map(page => {return {id: page.id, questions: page.questions.map(question => {return {data:question.data}})}}), 'page_data')") download 
                        v-btn(@click="downloadJSON(this.pages.map(page => {return {id: page.id, questions: page.questions.map(question => {return {data:question.data, image: question.base64Image}})}}), 'page_data_with_image')") download with image
            div.d-flex.w-100(style="position: absolute; bottom: 0px")
                v-btn(@click="prev") prev
                v-btn.ml-auto(@click="next") next

</template>

<script>
// Data 
import { getRandomID, downloadJSON } from '@/helpers'
import { ScanPage, ContextData } from '@/scan_api_classes.js' // Adjust the path as needed



// Components
import ImagesPreview from '@/components/image/ImagesPreview.vue'
import RequestLoader from '@/components/sub/RequestLoader.vue'

// Assets
import HAL from '@/assets/HAL.png'
import lege_student_row from '@/assets/lege_student_row.png'
import INPUT from '@/assets/input.png'
import TESTFOTO from '@/assets/crop_input.png'
import QRSECTION from '@/assets/qr_section_input.png'

export default {
    name: 'ScanView',
    components: {
        ImagesPreview,
        RequestLoader
    },
    setup(props) {
        return { downloadJSON }  
    },
    data() {
        return {
            selected_page_id:null,
            selected_step_index: 0,
            uploaded_images: [],
            pages: [], // Stores Page objects
            is_qr_scanner: false,
            all_loading_status: 'idle',

            context_data: new ContextData({}),

            question_string: "",
            rubric_string: "",
            context_string: "",

        }
    },
    computed: {
        selected_step() { return this.stepper_steps[this.selected_step_index] },
        stepper_steps(){
            if(this.is_qr_scanner){
                return [
                    'load images',
                    'crop images',
                    'apply color correction',
                    'extract qr sections and student id',
                    'extract sections',
                    'link answers',
                ]
            }
            return [
                'load images',
                'crop images',
                'apply color correction',
                'detect squares',
                'extract sections',
                'link answers',
            ]
        }
    },
    methods: {
        async convertImageToPNG(file) {
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader()
                reader.onload = () => resolve(reader.result)
                reader.onerror = reject
                reader.readAsDataURL(file)
            })
            return dataUrl.split(',')[1] // Remove "data:image/png;base64," prefix
        },
        async convertImportedImageToBase64(imageSrc) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous'; // This is needed if the image is hosted externally
                img.src = imageSrc instanceof File ? URL.createObjectURL(imageSrc) : imageSrc

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/png')); // Get the Base64 string
                };

                img.onerror = (error) => {
                    console.error("Error loading image:", error, "Source:", imageSrc);
                    reject(new Error("Failed to load image at " + imageSrc));
                };
            });
        },
        
        async addUploadedImages() {
            
            
            const pngImages = await Promise.all(
                this.uploaded_images.map(e => {
                    if (e.type == "application/pdf") {
                        return pdfToPng(e)
                    }
                    return this.convertImportedImageToBase64(e)
                })
            )
            pngImages.forEach(image => this.addImage(image))
        },

        addImage(base64Image) {
            const page = new ScanPage(base64Image, this.context_data)
            this.pages.push(page)
        },

        async cropImages() {
            await Promise.all(this.pages.map(page => page.cropImage()))
        },

        async applyColorCorrection() {
            await Promise.all(this.pages.map(page => page.colorCorrect()))
        },
        async extractQrSections(){
            await Promise.all(this.pages.map(async page => await page.detectQrSections()))
        },
        async extractStudentId(){
            await Promise.all(this.pages.map(async page => await page.detectStudentId()))
        },
        async detectSquares() {
            await Promise.all(this.pages.map(async page => {
                await page.detectSquares()
                await page.createSections()
            }))
            console.log(this.pages)
        },

        async extractSections() {
            await Promise.all(this.pages.map(page => page.createSections()))
        },
        async extractQuestions(){
            await Promise.all(this.pages.map(page => page.extractQuestions()))

        },
        async linkAnswers() {
            await Promise.all(this.pages.map(page => page.linkAnswers()))
        },
        async extractText() {
            await Promise.all(this.pages.map(page => page.extractText()))
        },
        async executeAllScanPage() {
            this.all_loading_status = 'started'
            await Promise.all(this.pages.map(page => page.scanPage()))
            this.all_loading_status = 'loaded'
        },
        async executeAll(){
            await Promise.all(this.pages.map(async page => {
                await page.cropImage()
                await page.colorCorrect()
                await Promise.all([page.detectStudentId(), page.detectSquares()])
                await page.createSections()
                await page.extractQuestions()
                await page.linkAnswers()
                await page.extractText()
            }))
        },
        next() {
            const actions = {
                'crop images': this.cropImages,
                'apply color correction': this.applyColorCorrection,
                'detect squares': this.detectSquares,
                'extract sections': this.extractSections,
                'link answers': this.linkAnswers
            }
            const action = actions[this.selected_step]
            if (action) action()
            this.selected_step_index++
        },

        prev() {
            this.selected_step_index--
        }
    },
    watch:{
        async is_qr_scanner(){
            if (this.is_qr_scanner){
                this.addImage(await this.convertImportedImageToBase64(QRSECTION))

            }
        }
    },
    async mounted() {
        // Load initial images as pages
        // this.addImage(HAL)
        // console.log(await this.convertImportedImageToBase64(INPUT))
        this.addImage(await this.convertImportedImageToBase64(TESTFOTO))
        console.log(this.pages)
    },
}
</script>
    
<style scoped>
/* Add any styling here */
.fill-height-image {
  display: flex;
  flex-flow: column;
  height: 100%;

  flex: 1 1 auto;
}
</style>


# ======================
# File: src\views\ScanViewOld.vue
# ======================

<template lang="pug">
div
    p {{ selected_step_index, selected_step}}
    v-stepper(v-model='selected_step_index' alt-labels)
        template(v-slot:default='{ prev, next }')
            v-stepper-header
                template(v-for='(step, index) in stepper_steps' :key='`${index}-step`')
                    v-stepper-item(
                        :complete='selected_step_index > index+1' 
                        :value="index+1"
                        :editable='index < selected_step_index'
                    ) {{ step }}
                    v-divider(v-if='index !== stepper_steps.length-1')
            
            v-stepper-window
                v-stepper-window-item.pa-0(
                    v-for='(step, index) in stepper_steps' 
                    :key='`${index-1}-content`' 
                    :value='index+1'
                )
                    h2 {{ step }}
                    div.w-100(v-if="step == 'load'")
                        ImagesPreview(
                            :images="images.map(e => e.original)"
                            height="500px"
                            :hasDeleteButton="true"
                            @delete="images.original.splice($event, 1)"
                        )
                        v-file-input(
                            label="foto's"
                            v-model="uploaded_images"
                            multiple
                            accept="image/*"
                        )
                        v-btn(@click="addUploadedImages") Voeg toe
                    div(v-if="step == 'fix'")
                        ImagesPreview(
                            :images="images.map((e, index) => [e.original, e.color_corrected])"
                            :titles="["before", "color_corrected"]"
                            height="500px"
                            :isBeforeAfter="true"
                        )
                    div(v-if="step == 'sections'")

                    div(v-if="step == 'text'")

                v-stepper-actions(
                    :disabled='false' 
                    @click:next='next' 
                    @click:prev='prev'
                )

</template>

<script>
// Data 
import { getRandomID }  from '@/helpers'

// Components
import ImagesPreview from '@/components/image/ImagesPreview.vue'

// Assets
import HAL from '@/assets/HAL.png'
import lege_student_row from '@/assets/lege_student_row.png'

export default {
    name: 'ScanView',
    components: {
        ImagesPreview
    },
    props: {
    
    },
    emits: [],
    setup() {
        
    },
    data(){
        return {
            stepper_steps: ['load', 'fix', 'sections', 'text'],
            selected_step_index: 2,

            pdf: null,
            uploaded_images: [],
            images: [
                
            ]
        }
    },
    computed: {
        selected_step(){return this.stepper_steps[this.selected_step_index]}
    },
    methods: {
        async convertImageToPNG(file) {
            // Read the file as a data URL
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });

            // Load the image
            const img = await new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = dataUrl;
            });

            // Draw the image onto a canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            // Convert the canvas content to a PNG data URL
            return canvas.toDataURL('image/png');
        },
        async addUploadedImages(){
            const png_images = await Promise.all(this.uploaded_images.map(e => this.convertImageToPNG(e)))
            png_images.forEach(e => this.addImage(e))
        },
        addImage(file){
            this.images.push({
                id: getRandomID(),
                original: file,
                is_loading: false,
                cropped: null,
                red_pen: null,
                color_corrected: null,
                sections: [],
                questions: []
            })
        }

        
    },
    watch: {
    
    },
    // created() {
    
    // },
    mounted() {
        this.addImage(HAL)
        this.addImage(lege_student_row)
    },
    
    
}
</script>
    
<style scoped>
    
</style>


# ======================
# File: src\workers\pdf.worker.js
# ======================

import * as pdfjsLib from 'pdfjs-dist'; // Correct import for non-legacy

self.onmessage = async (event) => {
  const {
    data,
    action,
    id
  } = event.data;

  if (action === 'pdfToBase64Images') {
    const base64Images = await pdfToBase64Images(data);
    self.postMessage({
      id,
      result: base64Images,
      action: 'pdfToBase64Images'
    });
  } else if (action === 'extractTextAndImages') {
    const extractedData = await extractTextAndImages(data);
    self.postMessage({
      id,
      result: extractedData,
      action: 'extractTextAndImages'
    });
  }
};

export async function pdfToBase64Images(pdfData) {
  const base64Images = [];
  try {
    const pdfDoc = await pdfjsLib.getDocument(pdfData).promise;
    const numPages = pdfDoc.numPages;

    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
      const page = await pdfDoc.getPage(pageNum);
      const operatorList = await page.getOperatorList();

      for (const op of operatorList.fnArray) {
        if (op === pdfjsLib.OPS.paintImageXObject || op === pdfjsLib.OPS.paintImageMaskXObject) {
          const imageName = operatorList.argsArray[operatorList.fnArray.indexOf(op)][0];
          try {
            const image = await new Promise((resolve) => {
              page.objs.get(imageName, (data) => resolve(data))
            });

            if (image) {
              const canvasImg = new OffscreenCanvas(image.width, image.height);
              const ctxImg = canvasImg.getContext('2d');
              const imgData = await image.bitmap;

              ctxImg.drawImage(imgData, 0, 0);
              base64Images.push(canvasImg.convertToBlob({
                type: 'image/png'
              }).then(blob => {
                return new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onloadend = () => {
                    // console.log('loaded Image: ', imageName)
                    resolve(reader.result)

                  };
                  reader.onerror = reject;
                  reader.readAsDataURL(blob);
                });
              }));
            } else {
              console.warn(`Image with name "${imageName}" not found in page.objs.`);
            }
          } catch (error) {
            console.error("Error extracting image:", error);
          }
        }
      }
    }

    return Promise.all(base64Images);
  } catch (error) {
    console.error("Error processing PDF:", error);
    return [];
  }
}

export async function extractTextAndImages(pdfData) {
  const extractedData = [];
  try {
    const pdfDoc = await pdfjsLib.getDocument(pdfData).promise;
    const numPages = pdfDoc.numPages;

    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
      const page = await pdfDoc.getPage(pageNum);

      // Extract text
      const textContent = await page.getTextContent();
      const textItems = textContent.items.map(item => item.str).join(' ');
      if (textItems.trim()) {
        extractedData.push({
          type: "text",
          data: textItems
        });
      }

      // Extract images
      const operatorList = await page.getOperatorList();
      for (const op of operatorList.fnArray) {
        if (op === pdfjsLib.OPS.paintImageXObject || op === pdfjsLib.OPS.paintImageMaskXObject) {
          const imageName = operatorList.argsArray[operatorList.fnArray.indexOf(op)][0];
          try {
            // await page.commonObjs.resolve(imageName); // Wait for the image object to be resolved
            const image = await new Promise((resolve) => {
              page.objs.get(imageName, (data) => resolve(data))
            });

            if (image) {
              const canvasImg = new OffscreenCanvas(image.width, image.height);
              const ctxImg = canvasImg.getContext('2d');
              const imgData = await image.bitmap;
              ctxImg.drawImage(imgData, 0, 0);
              const base64Image = await new Promise((resolve) => {
                canvasImg.convertToBlob({
                  type: 'image/png'
                }).then(blob => {
                  const reader = new FileReader();
                  reader.onloadend = () => resolve(reader.result);
                  reader.readAsDataURL(blob);
                });
              });
              extractedData.push({
                type: "image",
                data: base64Image
              });
            } else {
              console.warn(`Image with name "${imageName}" not found in page.objs.`);
            }
          } catch (error) {
            console.error("Error extracting image:", error);
          }
        }
      }
    }
    return extractedData;
  } catch (error) {
    console.error("Error processing PDF:", error);
    return [];
  }
}
